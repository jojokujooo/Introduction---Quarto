---
title: Types de donn√©es
---

### Types de Donn√©es (Structures s√©quentielles)

<p id=textIntro>Chaque type de donn√©es s√©quentielles offre des caract√©ristiques distinctes et des utilisations sp√©cifiques, permettant une grande souplesse dans le traitement des donn√©es. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilit√© et leurs capacit√©s de stockage dynamique, les rendant particuli√®rement populaires dans de nombreux sc√©narios d'utilisation.</p>

#### Les Chaines de Caract√®res

<p id=textIntro>
Les **cha√Ænes de caract√®res (str)** sont utilis√©es pour stocker et manipuler du texte. Elles peuvent √™tre d√©finies en encadrant le texte entre des guillemets **simples** ('...'), **doubles** ("..."), ou **triples** ('''...''' ou """...""") pour les cha√Ænes multilignes. <br>
Les cha√Ænes sont des s√©quences de caract√®res **index√©es √† partir de 0** et peuvent contenir des caract√®res sp√©ciaux, comme des guillemets, gr√¢ce aux caract√®res d'√©chappement (\). Les cha√Ænes de caract√®res offrent une gamme compl√®te de m√©thodes pour le traitement de texte, les rendant extr√™mement polyvalentes et **indispensables** pour une vari√©t√© d'applications, de manipulations de base √† des op√©rations plus complexes. Voici quelques exemples :
</p>

```{python}
# Exemples de chaines de caract√®res
# Chaine de caract√®res simple
maChaine = 'Python est un langage de programmation'

# Chaine de caract√®res double
maChaine2 = "Python est un langage de programmation"

# Chaine avec un caract√®re d'√©chappement
maChaine3 = 'Python c\'est trop bien'

print(maChaine)
print(maChaine2)
print(maChaine3)

# On peut acc√©der √† des √©l√©ments
# Premier caract√®re
premierCaractere = maChaine[0] # 'P'
# Dernier caract√®re
dernierCaractere = maChaine[-1] # 'n'

```
<p id=textIntro> 
Les m√©thodes sont des fonctions associ√©es √† des objets sp√©cifiques, leur permettant d'ex√©cuter des actions sur ces objets ou de manipuler leurs donn√©es internes. Contrairement aux fonctions ind√©pendantes, les m√©thodes sont li√©es √† des objets particuliers.
<br> Par exemple, les m√©thodes des **cha√Ænes de caract√®res (str)** sont con√ßues pour **op√©rer sur des cha√Ænes de caract√®res sp√©cifiques**. Elles sont appel√©es en utilisant la notation point√©e, comme **objet.methode()**. Les m√©thodes de cha√Ænes de caract√®res incluent des fonctionnalit√©s telles que **upper()**, **lower()**, et **replace()**, permettant de convertir en majuscules, en minuscules ou de remplacer des parties sp√©cifiques de la cha√Æne. Pour appeler une m√©thode, utilisez g√©n√©ralement la syntaxe objet.methode(arguments).
<br>
Pour utiliser ces m√©thodes vous pouvez les utiliser sur des variables contenant une chaine de caract√®res ou sur des chaines de caract√®res directement.
</p>

```{python}
# M√©thodes pour les cha√Ænes de caract√®res

# isupper() et islower()

chaineMaj = "PYTHON"
chaineMin = "python"
estMajuscule = chaineMaj.isupper()
estMinuscule = chaineMin.islower()
print(estMajuscule) # R√©sultat : True
print(estMinuscule) # R√©sultat : True

# upper() et lower()
chaine = "python est g√©nial"
minToMaj = chaine.upper()
print(minToMaj) # R√©sultat : "PYTHON EST G√âNIAL"

majToMin = "PYTHON est G√âNIAL".lower()
print(majToMin) # R√©sultat : "python est g√©nial"

chaineCapitalize = chaine.capitalize() # La premi√®re lettre est en majuscule
print(chaineCapitalize) # R√©sultat : "Python est g√©nial"

chaineTitle = chaine.title() # La premi√®re lettre de chaque mot est en majuscule
print(chaineTitle) # R√©sultat : "Python Est G√©nial"

position = chaine.find("est") # La m√©thode find() renvoie l'index de la premi√®re occurrence de la cha√Æne recherch√©e
print(position) # R√©sultat : 7

chaineReplace = "Les pommes sont rouges.".replace("pommes", "bananes") # La m√©thode replace() remplace une cha√Æne par une autre
print(chaineReplace) # R√©sultat : "Les bananes sont rouges."

chaineSplit = chaine.split(" ") # La m√©thode split() d√©coupe une cha√Æne en une liste de sous-cha√Ænes
print(chaineSplit) # R√©sultat : ["python", "est", "genial"]

elements = ["apple", "orange", "banana"]
textJoin = ", ".join(elements) # La m√©thode join() concat√®ne les √©l√©ments d'une liste
print(textJoin) # R√©sultat : "apple, orange, banana"

textStrip = " Bonjour ".strip() # La m√©thode strip() supprime les espaces en d√©but et fin de cha√Æne
print(textStrip) # R√©sultat : "Bonjour"

chaineStartsWith = chaine.startswith("Python")
print(chaineStartsWith) # R√©sultat : True

chaineEndsWith = chaine.endswith("g√©nial")
print(chaineEndsWith) # R√©sultat : True

```

#### Les listes
<p id=textIntro>
Les listes repr√©sentent des **structures de donn√©es** permettant de stocker une **s√©quence d'√©l√©ments**. Elles offrent une grande souplesse, car elles peuvent contenir des √©l√©ments de types vari√©s et sont modifiables. En tant que collections ordonn√©es, les √©l√©ments sont organis√©s de mani√®re **s√©quentielle**, s√©par√©s par des virgules et envelopp√©s entre crochets pour les chaines de caract√®res. Pour cr√©er une liste, il suffit d'encadrer une s√©rie d'√©l√©ments avec des crochets, s√©par√©s par des virgules, par exemple : ["Bonjour", "Au revoir", 75]. L'acc√®s aux √©l√©ments se fait en utilisant leur index, en commen√ßant par 0. √âtant donn√© que les listes sont **mutables**, il est possible de modifier leurs √©l√©ments **apr√®s leur cr√©ation**.
</p>

```{python}

# D√©finition d'une liste
maListe = [1, 2, 3, "a", "b", "c"]
print(maListe)

# Acc√®s au premier et au dernier √©l√©ment
premierElement = maListe[0]
dernierElement = maListe[-1]
print(premierElement, "\n", dernierElement)

# Modification du deuxi√®me √©l√©ment
maListe[1] = "deux" 
print(maListe)

# Concat√©nation et R√©p√©tition
combinee = maListe + ["autre", "liste"]
print(combinee)

repetee = [1, 2, 3] * 3
print(repetee)


```

##### Le Slicing
<p id=textIntro>En plus de permettre l'acc√®s aux √©l√©ments d'une liste un par un, Python propose une syntaxe concise appel√©e **slicing** pour acc√©der aux sous-listes.</p>

```{python}

# D√©finition d'une liste
maListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers

# Acc√®s √† une sous-liste en utilisant le slicing
sousListe1 = maListe[1:3]  # R√©cup√®re les √©l√©ments de l'index 1 inclus jusqu'√† l'index 3 non inclus
sousListe2 = maListe[:3]   # R√©cup√®re les trois premiers √©l√©ments de la liste
sousListe3 = maListe[2:]   # R√©cup√®re les √©l√©ments √† partir de l'index 2 jusqu'√† la fin de la liste
sousListe4 = maListe[::2]  # R√©cup√®re les √©l√©ments avec un pas de 2

# Affichage des sous-listes
print("Sous-liste 1:", sousListe1)  # R√©sultat : [1, 2]
print("Sous-liste 2:", sousListe2)  # R√©sultat : [0, 1, 2]
print("Sous-liste 3:", sousListe3)  # R√©sultat : [2, 3, 4]
print("Sous-liste 4:", sousListe4)  # R√©sultat : [0, 2, 4]

# Exemples de mutations de listes :

# Cas 1: source de m√™me longueur
nums1 = [1, 2, 3]
nums1[1:] = [4, 5]  # Remplace la sous-liste √† partir de l'index 1 par [4, 5]
print(nums1)  # R√©sultat : [1, 4, 5]

# Cas 2: source de longueur diff√©rente
nums2 = nums1
nums2[1:] = [6]  # Remplace la sous-liste √† partir de l'index 1 par [6]
print(nums2)  # R√©sultat : [1, 6]

# V√©rification si les deux listes pointent vers le m√™me objet en m√©moire
isSameObject = id(nums1) == id(nums2)  # V√©rifie si les listes pointent vers le m√™me objet
print(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifi√©es en place
```

##### Les m√©thodes de listes
<p id=textIntro>Chaque m√©thode offre une fonctionnalit√© unique pour manipuler des listes, rendant ces structures de donn√©es
extr√™mement flexibles et puissantes pour une vari√©t√© de t√¢ches en programmation Python.</p>

| **M√©thode** | **Description** | **Exemple d'Utilisation** |
| --- | --- | --- |
| **append()** | Ajoute **un √©l√©ment** √† la fin de la liste. | liste.append(5) |
| **extend()** | √âtend la liste en ajoutant **tous les √©l√©ments d'une autre liste**. | liste.extend([6, 7]) |
| **insert()** | Ins√®re un √©l√©ment √† une position donn√©e. | liste.insert(1, 'a') |
| **remove()** | Supprime la premi√®re occurrence d'un √©l√©ment. | liste.remove('a') |
| **pop()** | Supprime et renvoie un √©l√©ment √† une position donn√©e (par d√©faut, le dernier). | liste.pop() |
| **clear()** | Supprime tous les √©l√©ments de la liste. | liste.clear() |
| **index()** | Retourne l'indice du premier √©l√©ment correspondant. | liste.index('a') |
| **count()** | Compte le nombre d'occurrences d'un √©l√©ment sp√©cifique. | liste.count(5) |
| **sort()** | Trie les √©l√©ments de la liste (dans un ordre sp√©cifique). | liste.sort() |
| **reverse()** | Inverse l'ordre des √©l√©ments de la liste. | liste.reverse() |

```{python}
# Cr√©ation d'une liste de base
maListe = [1, 2, 3]
print(maListe)

# Ajout d'un √©l√©ment √† la fin de la liste avec append()
maListe.append("quatre")
print("Apr√®s append(quatre):", maListe)

# Extension de la liste en ajoutant les √©l√©ments d'une autre liste avec extend()
maListe.extend([5, 6])
print("Apr√®s extend([5, 6]):", maListe)

# Insertion d'un √©l√©ment √† un index sp√©cifique avec insert()
maListe.insert(1, 'elephant')
print("Apr√®s insert(1, 'elephant'):", maListe)

# Suppression de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec remove()
maListe.remove('elephant')
print("Apr√®s remove('elephant'):", maListe)

# Suppression et retour de l'√©l√©ment √† la fin de la liste avec pop()
elementSupprime = maListe.pop()
print("Apr√®s pop():", maListe, ", √âl√©ment supprim√©:", elementSupprime)

# Suppression de tous les √©l√©ments de la liste avec clear()
maListe.clear()
print("Apr√®s clear():", maListe)

# Recr√©ation de la liste pour les autres m√©thodes
maListe = [3, 1, 4, 2, 2]

# Recherche de l'index de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec index()
indexDe4 = maListe.index(4)
print("Index de 4:", indexDe4)

# Comptage du nombre d'occurrences d'un √©l√©ment sp√©cifi√© avec count()
compteDe2 = maListe.count(2)
print("Nombre d'occurrences de 2:", compteDe2)

# Tri des √©l√©ments de la liste dans l'ordre croissant avec sort()
maListe.sort()
print("Apr√®s sort():", maListe)

# Inversion de l'ordre des √©l√©ments dans la liste avec reverse()
maListe.reverse()
print("Apr√®s reverse():", maListe)

```

##### Parcours de liste
<p id=textIntro> Le parcours de liste consiste √† acc√©der s√©quentiellement √† chaque √©l√©ment d'une liste. Cela peut √™tre fait de diff√©rentes
mani√®res, mais les plus courantes sont les boucles **for** et **while** .</p>

* Boucle for : : La boucle for est la m√©thode la plus couramment utilis√©e pour parcourir une liste. Elle permet de traiter chaque √©l√©ment
individuellement.

* List Comprehension : La compr√©hension de liste est une m√©thode concise pour cr√©er des listes. Elle permet de transformer une liste en
une autre liste, en filtrant les √©l√©ments pour former une liste des r√©sultats d'une expression donn√©e

<p id=textIntro> La syntaxe de base d'une compr√©hension de liste est :
**[**``nouvelle_expression`` **for ``item`` **in** ``iterable`` **if** ``condition``**]**
<ul>
<li><p id=textIntro>**nouvelle_expression** est l'expression qui d√©finit comment **mapper** les √©l√©ments de l' iterable (par exemple, une liste).</p></li>
<li><p id=textIntro>**item** est la variable qui prend la valeur de chaque √©l√©ment de l' iterable pendant chaque it√©ration.</p></li>
<li><p id=textIntro> **condition** est une condition optionnelle pour filtrer les √©l√©ments de l' iterable. </p>
</li>
</ul>
<p id=textIntro>Nous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une **list comprehension** :</p>

```{python}

# r√©cup√©rer tous les fruits avec un "a"
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
autreListe = []
autreListe2 = []

# Avec une boucle for
for f in fruits:
    if "a" in f:
        autreListe.append(f)
print(autreListe)

# Avec une list comprehension
autreListe2 = [f for f in fruits if "a" in f ]
print(autreListe2)


```

<p id=textIntro>Nous pouvons voir que **les list comprehension** sont un moyen d'√©crire un code plus concis mais toujours autant compr√©hensible ! Alors pourquoi se prendre la t√™te avec une boucle for ? üòé
<br>
Elles peuvent aussi √™tre utilis√©es pour effectuer des calculs sur tous les √©l√©ments d'une liste. Voyons √ßa :</p>

```{python}
# Elevation des nombres d'une liste au carr√©
nombres = [2, 5, 10, 111]
nombreCarres = [x**2 for x in nombres]
print(nombreCarres) # [4, 25, 100, 12321]

# Filtrer les nombres pairs d'une liste
carresPairs = [x for x in nombreCarres if x%2==0]
print(carresPairs)

# Appliquer une m√©thode √† tous les √©l√©ments
fruits_majuscule = [fruit.upper() for fruit in fruits]
print(fruits_majuscule)

```

#### Les tuples

<p id=textIntro>Les tuples sont des listes **non mutables**. Cela signifie que les √©l√©ments d'un tuple ne peuvent pas √™tre modifi√©s apr√®s cr√©ation. Les √©l√©ments sont s√©par√©s par d√© virgules et sont entour√©s de parenth√®ses.</p>

| **Avantage**                      | **Description**                                               |
|------------------------------|-----------------------------------------------------------|
| **S√©curit√© des Donn√©es**         | Parfait pour prot√©ger les donn√©es contre les modifications. |
| **Performance**                  | Plus rapides √† parcourir que les listes.                 |
| **Utilisation en tant que Cl√©s de Dictionnaire** | Peuvent √™tre utilis√©s comme cl√©s dans les dictionnaires, contrairement aux listes. |
| **Retour de Plusieurs Valeurs de Fonction** | Utilis√©s pour retourner plusieurs valeurs depuis une fonction. |
| **Stockage de Donn√©es Constantes** | Id√©aux pour stocker des donn√©es qui ne doivent pas √™tre modifi√©es. |

```{python}
# D√©finition d'un tuple
monTuple = (10, "b", 3.14)
print(monTuple)

unAutreTuple = 20, "c", 4.28
print(unAutreTuple)

elementIndex1 = monTuple[1]
print(elementIndex1)

# Tuple √† Un √âl√©ment
tupleSingleton = 50,
print(tupleSingleton)

# Tuple √† Un √âl√©ment
tupleSingleton = (50,)

# Imbrication
tupleImbrique = (10, (20, 30), (40, 50))

# M√©thodes Utiles
longueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3
print(longueur)

compteur = monTuple.count("b")  # Compte le nombre de fois que "b" appara√Æt dans monTuple, ici 1
print(compteur)

indice = monTuple.index("b")  # Trouve l'indice de "b" dans monTuple, ici 1
print(indice)

# L'affectation n'est pas possible
# monTuple[1] = "c"

```

#### Les ensembles
<p id=textIntro>Les ensembles sont :</p>

* Des collections non ordonn√©es de **valeurs uniques**

* **Mutables**, mais chaque √©l√©ment doit √™tre **unique**.

* **Non-Ordonn√©s** : Les ensembles ne **maintiennent pas** l'ordre des √©l√©ments. On ne peut donc pas acc√©der aux √©l√©ments par un index.

* Les √©l√©ments sont s√©par√©s par des virgules, et encadr√©s par des accolades

##### Op√©rations sur les ensembles

| **Op√©ration**         | **Syntaxe**    | Description                                                                              |
|-----------------------|---------------|------------------------------------------------------------------------------------------|
| **Union**             | **a \| b**    | Retourne un nouvel ensemble contenant tous les √©l√©ments uniques des ensembles a et b.   |
| **Intersection**      | **a & b**     | Retourne un nouvel ensemble contenant uniquement les √©l√©ments communs aux ensembles a et b. |
| **Diff√©rence**        | **a - b**     | Retourne un nouvel ensemble contenant les √©l√©ments de a qui ne sont pas dans b.          |
| **Diff√©rence Sym√©trique** | **a ^ b** | Retourne un nouvel ensemble contenant tous les √©l√©ments qui sont dans a ou b, mais pas dans les deux. |
| **Ajout**             | **a.add(x)**  | Ajoute l'√©l√©ment x √† l'ensemble a.                                                     |
| **Suppression**       | **a.remove(x)**| Supprime l'√©l√©ment x de l'ensemble a ; **l√®ve une erreur si x n'est pas pr√©sent**.           |
| **Suppression (sans erreur)** | **a.discard(x)** | Supprime l'√©l√©ment x de l'ensemble a si x est pr√©sent ; **ne fait rien sinon**.           |

#### Les dictionnaires

<p id=textIntro>Les dictionnaires sont un peu comme un format de JSON :</p>

* Ils sont bas√©s sur des paires **cl√©s-valeurs**
* On acc√®de aux valeurs via les **cl√©s**
* Ils sont **mutables**, on peut y **ajouter** des √©l√©ments, en **supprimer** ou en **modifier**
*   
* Utilisation :
- **Stockage d'Informations Structur√©es** : Parfait pour stocker des informations complexes comme des donn√©es utilisateur.
- **Recherche Rapide** : Utilisez des dictionnaires pour des recherches rapides bas√©es sur des cl√©s uniques







