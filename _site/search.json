[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Les Fondamentaux de Python",
    "section": "",
    "text": "Bonjour ! Moi c‚Äôest Johann Cazenave, le rempla√ßant temporaire de votre prof de programmation M√©nyssa Ch√©rifa-Luron, Ph.D car elle n‚Äôest pas encore rentr√©e de son voyage en Cor√©e. Mais ce n‚Äôest pas pour autant que vous allez rater cette magnifique formation !\n\n\nAu programme ? Une r√©vision des bases de Python car c‚Äôest souvent celles que l‚Äôon n√©glige le plus et qui sont finalement les bases de tout langage de programmation.\n\n\nMais Johann, c‚Äôest quoi Python ?\n\nPython, c‚Äôest un peu comme un  super-h√©ros de la programmation, n√© en 1989 dans l‚Äôesprit cr√©atif de Guido van Rossum, un fan de la com√©die absurde des Monty Python. C‚Äôest un langage de programmation qui a tout pour plaire : il est polyvalent, gratuit comme l‚Äôair que vous respirez, et tellement simple √† utiliser que m√™me votre grand-m√®re pourrait s‚Äôy mettre (peut-√™tre m√™me votre chat, qui sait ?). Avec Python, vous pouvez jongler avec des milliers de lignes de code sans jamais vous prendre les pieds dans le tapis, car il est con√ßu pour √™tre aussi convivial qu‚Äôun panda c√¢lin. Vous pouvez l‚Äôinstaller sur tous vos gadgets √©lectroniques, du PC de papa √† votre smartphone dernier cri, sans d√©bourser un sou. Et le meilleur dans tout √ßa ? Pas besoin de vous tracasser avec des compilateurs compliqu√©s : Python est un langage interpr√©t√©, ce qui signifie que vous pouvez voir les r√©sultats de votre travail en un clin d‚Äô≈ìil, sans avoir √† attendre des heures que votre code se transforme en quelque chose de tangible. Alors, pr√™t √† devenir un super-h√©ros de la programmation avec Python ? Clique ici !"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "C‚Äôest vraiment ghetto les cours de programmation avec elle l√†"
  },
  {
    "objectID": "index.html#la-variable-prout",
    "href": "index.html#la-variable-prout",
    "title": "Les Fondamentaux de Python",
    "section": "La variable prout",
    "text": "La variable prout"
  },
  {
    "objectID": "index.html#les-variables",
    "href": "index.html#les-variables",
    "title": "Les Fondamentaux de Python",
    "section": "Les variables",
    "text": "Les variables\n\nConcr√®tement, les variables sont juste des √©l√©ments qui peuvent contenir des donn√©es, m√™me si c‚Äôest plus compliqu√© que √ßa si vous le retenez c‚Äôest d√©j√† pas mal. Elles sont d√©clar√©es avec le nom de la variable suivi d‚Äôun =, puis de leurs valeurs.\n\n\nPar exemple, si je veux cr√©er une variable qui contient le nombre 1, je peux √©crire :\n\n\na = 1\na\n\n1\n\n\n\nMais n‚Äôoubliez pas, il y a quand m√™me des r√®gles pour nommer les variables : pas de chiffres au d√©but, pas de symboles bizarres, et ne pas m√©langer des mots et des chiffres directement.\n\n\nDe plus, il y a diff√©rentes mani√®res de nommer une variable, voici des exemples :\n\n\nLe camelCase : Consiste √† √©crire chaque mot commen√ßant par une majuscule sauf le premier et sans espaces\nLe snake_case : Consiste √† √©crire chaque mot s√©par√© par un underscore\nLe PascalCase : Consiste √† √©crire chaque mot commen√ßant par une majuscule et sans espaces\n\n\nmaVariableExemple = 1       # Ceci est une variable √©crite en camelCase\n\nma_variable_exemple = 1     # Ceci est une variable √©crite en snake_case\n\nMaVariableExemple = 1       # Ceci est une variable √©crite en PascalCase\n\n\nIl y a √©galement plusieurs moyens de donner une valeur √† une variable, voici les exemples les plus communs :\n\n\n# Voici l'affectation simple\nmaVariable = 5    \n\n# Voici l'affectation par d√©composition\nmaVar1, maVar2, maVar3 = \"valeur 1\", \"valeur 2\", \"valeur 3\"\nprint(maVar1, maVar2, maVar3)\n\n# Voici l'affectation de la m√™me valeur √† plusieurs variables\nmaVar1 = maVar2 = maVar3 = 20   \nprint(maVar1, maVar2, maVar3)\n\nvaleur 1 valeur 2 valeur 3\n20 20 20\n\n\n\nLes types de variables\n\nIl y a plusieurs types de variables en Python. Les types de variables en Python sont des cat√©gories qui d√©finissent le type de donn√©es qu‚Äôune variable peut contenir. En Python, nous rencontrons principalement trois types de variables :\n\n\nLes variables num√©riques : les variables num√©riques sont des variables qui peuvent contenir des nombres. On peut en trouver de diff√©rents types : entiers(int), d√©cimaux(float) et m√™me complexes(complex) (1, 2.5, 4+2j)\nLes variables de cha√Æne de caract√®res : Les cha√Ænes de caract√®res, plus commun√©ment appel√©es ‚Äústring‚Äù sont des variables qui peuvent contenir du texte. Comme ‚ÄúBonjour‚Äù ou m√™me des paragraphes entiers ! La sp√©cificit√© des string c‚Äôest qu‚Äôelles peuvent √™tre d√©limit√©es par des guillemets simples (‚Äô ‚Äò), doubles (‚Äù ‚Äú) ou triples (‚Äô‚Äô‚Äô ‚Äô‚Äô‚Äô). La particularit√© des guillemets triples c‚Äôest qu‚Äôelles peuvent contenir des sauts de ligne.\nLes variables bool√©ennes : Les variables bool√©ennes sont des variables qui peuvent contenir des valeurs bool√©ennes donc soit vraie (True) soit fausse (False). Elles sont utilis√©es pour repr√©senter des conditions ou des √©tats logiques.\n\n\nnomSimple = 'M√©nyssa'\nnomDouble = \"Johann\"\nnomTriple = '''Fr√©\nd√©\nric'''\nage = 22\ntaille = 1.82\nestVrai = True\nestFaux = False\n\nprint(\"La variable nomSimple est de type: \", type(nomSimple))\nprint(\"La variable age est de type: \", type(age))\nprint(\"La variable taille est de type: \", type(taille))\nprint(\"La variable estVrai est de type: \",type(estVrai))\n\nLa variable nomSimple est de type:  &lt;class 'str'&gt;\nLa variable age est de type:  &lt;class 'int'&gt;\nLa variable taille est de type:  &lt;class 'float'&gt;\nLa variable estVrai est de type:  &lt;class 'bool'&gt;\n\n\n\n\nConversion de types\n\nIl est possible de convertir un type de variable en un autre. Il existe des fonctions appel√©es cast ou casting. Voici quelques exemples :\n\n\n# Fonctions utilis√©es : int(), str(), bool(), float()\n# Conversion en entier\n## Depuis une chaine de caract√®res\nchaine = \"200\"\nchaineEnEntier = int(chaine) # On convertit la chaine en nombre\n\n## Depuis un bool√©en\nboolEnEntier= int(estVrai) # On convertit le bool√©en en nombre\n\n## Flottant en nombre\nfloatEnEntier = int(taille) # On convertit le flottant en nombre, il est troncatur√© mais pas arrondi\n\n# Conversion en Chaine de Caract√®res\n## Depuis un entier ou un flottant\nentierEnChaine = str(chaineEnEntier) # On convertit le nombre en chaine\n\n## Depuis un bool√©en\nboolEnChaine = str(estVrai) # Convertit False en \"False\" et True en \"True\"\n\n# Conversion en bool√©en\n## Depuis une chaine de caract√®res\nchaineEnBool = bool(chaine) # Convertit une chaine non-vide en True et une chaine vide en False\n\n## Depuis un nombre\nnombreEnBool = bool(chaineEnEntier) # Convertit 0 en False et tout autre nombre en True\n\n# Conversion en flottant\n## Depuis une chaine de caract√®res\nchaineEnFlottant = float(chaine) # Convertit une chaine de caract√®res en flottant\n\n## Depuis un entier\nentierEnFlottant = float(chaineEnEntier) # Convertit 200 en 200.0\n\n## Depuis un bool√©en\nboolEnFlottant = float(estVrai) # Convertit True en 1.0 et False en 0.0\n\n\n\nOp√©rations Arithm√©tiques"
  },
  {
    "objectID": "var_ope.html",
    "href": "var_ope.html",
    "title": "Variables et op√©rations",
    "section": "",
    "text": "Concr√®tement, les variables sont juste des √©l√©ments qui peuvent contenir des donn√©es, m√™me si c‚Äôest plus compliqu√© que √ßa si vous le retenez c‚Äôest d√©j√† pas mal. Elles sont d√©clar√©es avec le nom de la variable suivi d‚Äôun =, puis de leurs valeurs.\n\n\nPar exemple, si je veux cr√©er une variable qui contient le nombre 1, je peux √©crire :\n\n\na = 1\na\n\n1\n\n\n\nMais n‚Äôoubliez pas, il y a quand m√™me des r√®gles pour nommer les variables : pas de chiffres au d√©but, pas de symboles bizarres, et ne pas m√©langer des mots et des chiffres directement.\n\n\nDe plus, il y a diff√©rentes mani√®res de nommer une variable, voici des exemples :\n\n\nLe camelCase : Consiste √† √©crire chaque mot commen√ßant par une majuscule sauf le premier et sans espaces\nLe snake_case : Consiste √† √©crire chaque mot s√©par√© par un underscore\nLe PascalCase : Consiste √† √©crire chaque mot commen√ßant par une majuscule et sans espaces\n\n\nmaVariableExemple = 1       # Ceci est une variable √©crite en camelCase\n\nma_variable_exemple = 1     # Ceci est une variable √©crite en snake_case\n\nMaVariableExemple = 1       # Ceci est une variable √©crite en PascalCase\n\n\nIl y a √©galement plusieurs moyens de donner une valeur √† une variable, voici les exemples les plus communs :\n\n\n# Voici l'affectation simple\nmaVariable = 5    \n\n# Voici l'affectation par d√©composition\nmaVar1, maVar2, maVar3 = \"valeur 1\", \"valeur 2\", \"valeur 3\"\nprint(maVar1, maVar2, maVar3)\n\n# Voici l'affectation de la m√™me valeur √† plusieurs variables\nmaVar1 = maVar2 = maVar3 = 20   \nprint(maVar1, maVar2, maVar3)\n\nvaleur 1 valeur 2 valeur 3\n20 20 20\n\n\n\n\n\nIl y a plusieurs types de variables en Python. Les types de variables en Python sont des cat√©gories qui d√©finissent le type de donn√©es qu‚Äôune variable peut contenir. En Python, nous rencontrons principalement trois types de variables :\n\n\nLes variables num√©riques : les variables num√©riques sont des variables qui peuvent contenir des nombres. On peut en trouver de diff√©rents types : entiers(int), d√©cimaux(float) et m√™me complexes(complex) (1, 2.5, 4+2j)\nLes variables de cha√Æne de caract√®res : Les cha√Ænes de caract√®res, plus commun√©ment appel√©es ‚Äústring‚Äù sont des variables qui peuvent contenir du texte. Comme ‚ÄúBonjour‚Äù ou m√™me des paragraphes entiers ! La sp√©cificit√© des string c‚Äôest qu‚Äôelles peuvent √™tre d√©limit√©es par des guillemets simples (‚Äô ‚Äò), doubles (‚Äù ‚Äú) ou triples (‚Äô‚Äô‚Äô ‚Äô‚Äô‚Äô). La particularit√© des guillemets triples c‚Äôest qu‚Äôelles peuvent contenir des sauts de ligne.\nLes variables bool√©ennes : Les variables bool√©ennes sont des variables qui peuvent contenir des valeurs bool√©ennes donc soit vraie (True) soit fausse (False). Elles sont utilis√©es pour repr√©senter des conditions ou des √©tats logiques.\n\n\nnomSimple = 'M√©nyssa'\nnomDouble = \"Johann\"\nnomTriple = '''Fr√©\nd√©\nric'''\nage = 22\ntaille = 1.82\nestVrai = True\nestFaux = False\n\nprint(\"La variable nomSimple est de type: \", type(nomSimple))\nprint(\"La variable age est de type: \", type(age))\nprint(\"La variable taille est de type: \", type(taille))\nprint(\"La variable estVrai est de type: \",type(estVrai))\n\nLa variable nomSimple est de type:  &lt;class 'str'&gt;\nLa variable age est de type:  &lt;class 'int'&gt;\nLa variable taille est de type:  &lt;class 'float'&gt;\nLa variable estVrai est de type:  &lt;class 'bool'&gt;\n\n\n\n\n\n\nIl est possible de convertir un type de variable en un autre. Il existe des fonctions appel√©es cast ou casting. Voici quelques exemples :\n\n\n# Fonctions utilis√©es : int(), str(), bool(), float()\n# Conversion en entier\n## Depuis une chaine de caract√®res\nchaine = \"200\"\nchaineEnEntier = int(chaine) # On convertit la chaine en nombre\n\n## Depuis un bool√©en\nboolEnEntier= int(estVrai) # On convertit le bool√©en en nombre\n\n## Flottant en nombre\nfloatEnEntier = int(taille) # On convertit le flottant en nombre, il est troncatur√© mais pas arrondi\n\n# Conversion en Chaine de Caract√®res\n## Depuis un entier ou un flottant\nentierEnChaine = str(chaineEnEntier) # On convertit le nombre en chaine\n\n## Depuis un bool√©en\nboolEnChaine = str(estVrai) # Convertit False en \"False\" et True en \"True\"\n\n# Conversion en bool√©en\n## Depuis une chaine de caract√®res\nchaineEnBool = bool(chaine) # Convertit une chaine non-vide en True et une chaine vide en False\n\n## Depuis un nombre\nnombreEnBool = bool(chaineEnEntier) # Convertit 0 en False et tout autre nombre en True\n\n# Conversion en flottant\n## Depuis une chaine de caract√®res\nchaineEnFlottant = float(chaine) # Convertit une chaine de caract√®res en flottant\n\n## Depuis un entier\nentierEnFlottant = float(chaineEnEntier) # Convertit 200 en 200.0\n\n## Depuis un bool√©en\nboolEnFlottant = float(estVrai) # Convertit True en 1.0 et False en 0.0\n\n\n\n\n\nLes op√©rations arithm√©tiques sont les m√™mes que dans les autres langages. Voici des exemples d‚Äôutilisation d‚Äôop√©rations\n\n\n# Addition (+)\nsomme = 6 + 5\n# Soustraction (-)\ndifference = 6 - 5\n\n# Multiplication \nproduit = 6 * 5\n\n# Division (/)\n\nquotient = 6 / 5\n\n# Modulo (%) Permet de calculer le reste d'une division\nreste = 6 % 5\n\n# Puissance(**) Permet d'√©lever un nombre √† une puissance\npuissance = 6 ** 5\n\n\n\n\n\nNous pouvons utiliser certaines op√©rations sur des chaines de caract√®res comme :\n\n\nL‚Äôaddition (+) : Permet de combiener des chaines de caract√®res\nLa multiplication (*) : Permet de r√©p√©ter une chaine de caract√®res le nombre de fois que l‚Äôon donne\n\n\nVoici des exemples d‚Äôutilisation d‚Äôop√©rations\n\n\n# Addition (+)\nchaine1 = \"Bonjour\"\nchaine2 = \"tout le monde\" \n\nchaineCombinee = chaine1 + chaine2 # Affiche \"Bonjour tout le monde\"\nprint(chaineCombinee)\n# Multiplication (*)\nchaineRepetee = chaine1 * 3 # Affiche \"BonjourBonjourBonjour\"\nprint(chaineRepetee)\n\nBonjourtout le monde\nBonjourBonjourBonjour\n\n\n\n\n\n\nLes op√©rateurs d‚Äôaffectations compos√©es sont des op√©rateurs qui permettent de combiner des op√©rations arithm√©tiques et des affectations √† des variable. Simplifiant ainsi le code en effectuant une op√©ration sur une variable et en lui r√©affectant le r√©sultat en une seule ligne de code.\n\n\nVoici des exemples d‚Äôutilisation d‚Äôop√©rateurs d‚Äôaffectation :\n\n\n# Cr√©ation / Initialisation de la variable\nnombre = 10\n\n# Op√©rateur d'affectation combin√©e\n# Addition et assignation\nnombre += 5 # nombre = nombre + 5\nprint(nombre) # Affiche 15\n\n# Soustraction et assignation\nnombre -= 5 # nombre = nombre - 5\nprint(nombre) # Affiche 10\n\n# Multiplication et assignation\nnombre *= 5 # nombre = nombre * 5\nprint(nombre) # Affiche 50\n\n# Division et assignation\nnombre /= 5 # nombre = nombre / 5\nprint(nombre) # Affiche 10.0\n\n# Division enti√®re et assignation\nnombre //= 2 # nombre = nombre // 2\nprint(nombre) # Affiche 5\n\n# Modulo et assignation\nnombre %= 3 # nombre = nombre % 3\nprint(nombre) # Affiche 2.0\n\n# Puissance et assignation\nnombre **= 2 # nombre = nombre ** 2\nprint(nombre) # Affiche 4.0\n\n15\n10\n50\n10.0\n5.0\n2.0\n4.0\n\n\n\nNous en avons enfin fini avec les variables ! Etes vous pr√™t pour la suite ? Cliquez-ici pour passer √† la suite."
  },
  {
    "objectID": "var_ope.html#les-variables",
    "href": "var_ope.html#les-variables",
    "title": "Variables et op√©rations",
    "section": "",
    "text": "Concr√®tement, les variables sont juste des √©l√©ments qui peuvent contenir des donn√©es, m√™me si c‚Äôest plus compliqu√© que √ßa si vous le retenez c‚Äôest d√©j√† pas mal. Elles sont d√©clar√©es avec le nom de la variable suivi d‚Äôun =, puis de leurs valeurs.\n\n\nPar exemple, si je veux cr√©er une variable qui contient le nombre 1, je peux √©crire :\n\n\na = 1\na\n\n1\n\n\n\nMais n‚Äôoubliez pas, il y a quand m√™me des r√®gles pour nommer les variables : pas de chiffres au d√©but, pas de symboles bizarres, et ne pas m√©langer des mots et des chiffres directement.\n\n\nDe plus, il y a diff√©rentes mani√®res de nommer une variable, voici des exemples :\n\n\nLe camelCase : Consiste √† √©crire chaque mot commen√ßant par une majuscule sauf le premier et sans espaces\nLe snake_case : Consiste √† √©crire chaque mot s√©par√© par un underscore\nLe PascalCase : Consiste √† √©crire chaque mot commen√ßant par une majuscule et sans espaces\n\n\nmaVariableExemple = 1       # Ceci est une variable √©crite en camelCase\n\nma_variable_exemple = 1     # Ceci est une variable √©crite en snake_case\n\nMaVariableExemple = 1       # Ceci est une variable √©crite en PascalCase\n\n\nIl y a √©galement plusieurs moyens de donner une valeur √† une variable, voici les exemples les plus communs :\n\n\n# Voici l'affectation simple\nmaVariable = 5    \n\n# Voici l'affectation par d√©composition\nmaVar1, maVar2, maVar3 = \"valeur 1\", \"valeur 2\", \"valeur 3\"\nprint(maVar1, maVar2, maVar3)\n\n# Voici l'affectation de la m√™me valeur √† plusieurs variables\nmaVar1 = maVar2 = maVar3 = 20   \nprint(maVar1, maVar2, maVar3)\n\nvaleur 1 valeur 2 valeur 3\n20 20 20\n\n\n\n\n\nIl y a plusieurs types de variables en Python. Les types de variables en Python sont des cat√©gories qui d√©finissent le type de donn√©es qu‚Äôune variable peut contenir. En Python, nous rencontrons principalement trois types de variables :\n\n\nLes variables num√©riques : les variables num√©riques sont des variables qui peuvent contenir des nombres. On peut en trouver de diff√©rents types : entiers(int), d√©cimaux(float) et m√™me complexes(complex) (1, 2.5, 4+2j)\nLes variables de cha√Æne de caract√®res : Les cha√Ænes de caract√®res, plus commun√©ment appel√©es ‚Äústring‚Äù sont des variables qui peuvent contenir du texte. Comme ‚ÄúBonjour‚Äù ou m√™me des paragraphes entiers ! La sp√©cificit√© des string c‚Äôest qu‚Äôelles peuvent √™tre d√©limit√©es par des guillemets simples (‚Äô ‚Äò), doubles (‚Äù ‚Äú) ou triples (‚Äô‚Äô‚Äô ‚Äô‚Äô‚Äô). La particularit√© des guillemets triples c‚Äôest qu‚Äôelles peuvent contenir des sauts de ligne.\nLes variables bool√©ennes : Les variables bool√©ennes sont des variables qui peuvent contenir des valeurs bool√©ennes donc soit vraie (True) soit fausse (False). Elles sont utilis√©es pour repr√©senter des conditions ou des √©tats logiques.\n\n\nnomSimple = 'M√©nyssa'\nnomDouble = \"Johann\"\nnomTriple = '''Fr√©\nd√©\nric'''\nage = 22\ntaille = 1.82\nestVrai = True\nestFaux = False\n\nprint(\"La variable nomSimple est de type: \", type(nomSimple))\nprint(\"La variable age est de type: \", type(age))\nprint(\"La variable taille est de type: \", type(taille))\nprint(\"La variable estVrai est de type: \",type(estVrai))\n\nLa variable nomSimple est de type:  &lt;class 'str'&gt;\nLa variable age est de type:  &lt;class 'int'&gt;\nLa variable taille est de type:  &lt;class 'float'&gt;\nLa variable estVrai est de type:  &lt;class 'bool'&gt;\n\n\n\n\n\n\nIl est possible de convertir un type de variable en un autre. Il existe des fonctions appel√©es cast ou casting. Voici quelques exemples :\n\n\n# Fonctions utilis√©es : int(), str(), bool(), float()\n# Conversion en entier\n## Depuis une chaine de caract√®res\nchaine = \"200\"\nchaineEnEntier = int(chaine) # On convertit la chaine en nombre\n\n## Depuis un bool√©en\nboolEnEntier= int(estVrai) # On convertit le bool√©en en nombre\n\n## Flottant en nombre\nfloatEnEntier = int(taille) # On convertit le flottant en nombre, il est troncatur√© mais pas arrondi\n\n# Conversion en Chaine de Caract√®res\n## Depuis un entier ou un flottant\nentierEnChaine = str(chaineEnEntier) # On convertit le nombre en chaine\n\n## Depuis un bool√©en\nboolEnChaine = str(estVrai) # Convertit False en \"False\" et True en \"True\"\n\n# Conversion en bool√©en\n## Depuis une chaine de caract√®res\nchaineEnBool = bool(chaine) # Convertit une chaine non-vide en True et une chaine vide en False\n\n## Depuis un nombre\nnombreEnBool = bool(chaineEnEntier) # Convertit 0 en False et tout autre nombre en True\n\n# Conversion en flottant\n## Depuis une chaine de caract√®res\nchaineEnFlottant = float(chaine) # Convertit une chaine de caract√®res en flottant\n\n## Depuis un entier\nentierEnFlottant = float(chaineEnEntier) # Convertit 200 en 200.0\n\n## Depuis un bool√©en\nboolEnFlottant = float(estVrai) # Convertit True en 1.0 et False en 0.0\n\n\n\n\n\nLes op√©rations arithm√©tiques sont les m√™mes que dans les autres langages. Voici des exemples d‚Äôutilisation d‚Äôop√©rations\n\n\n# Addition (+)\nsomme = 6 + 5\n# Soustraction (-)\ndifference = 6 - 5\n\n# Multiplication \nproduit = 6 * 5\n\n# Division (/)\n\nquotient = 6 / 5\n\n# Modulo (%) Permet de calculer le reste d'une division\nreste = 6 % 5\n\n# Puissance(**) Permet d'√©lever un nombre √† une puissance\npuissance = 6 ** 5\n\n\n\n\n\nNous pouvons utiliser certaines op√©rations sur des chaines de caract√®res comme :\n\n\nL‚Äôaddition (+) : Permet de combiener des chaines de caract√®res\nLa multiplication (*) : Permet de r√©p√©ter une chaine de caract√®res le nombre de fois que l‚Äôon donne\n\n\nVoici des exemples d‚Äôutilisation d‚Äôop√©rations\n\n\n# Addition (+)\nchaine1 = \"Bonjour\"\nchaine2 = \"tout le monde\" \n\nchaineCombinee = chaine1 + chaine2 # Affiche \"Bonjour tout le monde\"\nprint(chaineCombinee)\n# Multiplication (*)\nchaineRepetee = chaine1 * 3 # Affiche \"BonjourBonjourBonjour\"\nprint(chaineRepetee)\n\nBonjourtout le monde\nBonjourBonjourBonjour\n\n\n\n\n\n\nLes op√©rateurs d‚Äôaffectations compos√©es sont des op√©rateurs qui permettent de combiner des op√©rations arithm√©tiques et des affectations √† des variable. Simplifiant ainsi le code en effectuant une op√©ration sur une variable et en lui r√©affectant le r√©sultat en une seule ligne de code.\n\n\nVoici des exemples d‚Äôutilisation d‚Äôop√©rateurs d‚Äôaffectation :\n\n\n# Cr√©ation / Initialisation de la variable\nnombre = 10\n\n# Op√©rateur d'affectation combin√©e\n# Addition et assignation\nnombre += 5 # nombre = nombre + 5\nprint(nombre) # Affiche 15\n\n# Soustraction et assignation\nnombre -= 5 # nombre = nombre - 5\nprint(nombre) # Affiche 10\n\n# Multiplication et assignation\nnombre *= 5 # nombre = nombre * 5\nprint(nombre) # Affiche 50\n\n# Division et assignation\nnombre /= 5 # nombre = nombre / 5\nprint(nombre) # Affiche 10.0\n\n# Division enti√®re et assignation\nnombre //= 2 # nombre = nombre // 2\nprint(nombre) # Affiche 5\n\n# Modulo et assignation\nnombre %= 3 # nombre = nombre % 3\nprint(nombre) # Affiche 2.0\n\n# Puissance et assignation\nnombre **= 2 # nombre = nombre ** 2\nprint(nombre) # Affiche 4.0\n\n15\n10\n50\n10.0\n5.0\n2.0\n4.0\n\n\n\nNous en avons enfin fini avec les variables ! Etes vous pr√™t pour la suite ? Cliquez-ici pour passer √† la suite."
  },
  {
    "objectID": "comm_affiche.html",
    "href": "comm_affiche.html",
    "title": "Commentaires et Affichage",
    "section": "",
    "text": "Commentaires\n\nLes commentaires sont utilis√©s pour expliquer le code. Ils sont utiles pour vous mais surtout pour ceux qui vont lire votre code. Ils commencent par un # et prennent toute une ligne sauf s‚Äôils suivent une instruction. A noter qu‚Äôils ne sont pas comptabilis√©s quand on ex√©cute du code Alors simplifiez la vie de votre prof et commentez votre code !\n\n\n# Voici un commentaire\n\nvariableTest = 2 # Voici un commentaire qui suit une ligne de code\n\n\n\nAffichage\n\nEn Python, pour afficher du texte, le contenu d‚Äôune variable ou m√™me les deux, on utilise la fonction print().\n\n\nprint(\"Mes √©l√®ves sont les meilleurs\") # Affiche le texte entre les guillemets\nprint(variableTest) # Affiche la valeur de la variable\nprint(\"Mes √©l√®ves sont les meilleurs\", variableTest) # Affiche le texte entre les guillemets et la valeur de la variable\n\nMes √©l√®ves sont les meilleurs\n2\nMes √©l√®ves sont les meilleurs 2\n\n\n\n\nFormatage\n\nPour afficher du texte ainsi que des variables dans une m√™me ligne il existe aussi une autre m√©thode que l‚Äôon appelle les f-strings. En utilisant les f-strings, vous pouvez ins√©rer des variables directement dans une cha√Æne de caract√®res en pla√ßant leur nom entre des accolades {} √† l‚Äôint√©rieur de la cha√Æne. Cela am√©liore grandement la lisibilit√©. Mais pour cela il faut placer un f DEVANT la cha√Æne de caract√®res. Voici un exemple :\n\n\nprenom = \"Johann\"\nage = \"22\"\nprint(f\"Je m'appelle {prenom} et j'ai {age} ans\")\n\nJe m'appelle Johann et j'ai 22 ans\n\n\n\nL‚Äôutilisation de la m√©thode .format() en Python permet aussi d‚Äôins√©rer des variables dans des cha√Ænes de caract√®res en sp√©cifiant des emplacements r√©serv√©s (placeholders) avec des accolades {} , puis en utilisant la m√©thode .format() apr√®s la chaine de caract√®res pour remplacer ces emplacements par les valeurs des variables.\n\n\n# Utilisation de format()\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(prenom, age))\n\nBonjour, je m'appelle Johann et j'ai 22 ans.\n\n\n\n\nCalcul et arrondi\n\nDans votre vie de programmeur, vous effectuerez souvent des calculs. Mais leur r√©sultat seront peut-√™tre parfois trop pr√©cis, donc il faudra les arrondir ! Dans l‚Äôexemple suivant on va faire un calcul puis l‚Äôafficher une premi√®re fois sans l‚Äôarrondir puis un autre fois arrondi.\n\n\n# Calcul\nresultat = 10 / 3\n\n# Affichage\nprint(f\"Le r√©sultat pas arrondi est {resultat}\")\n\n# Arrondi √† deux chiffres apr√®s la virgule\n\nprint(f\"Le r√©sultat arrondi est : {resultat:.2f}\")\n\nLe r√©sultat pas arrondi est 3.3333333333333335\nLe r√©sultat arrondi est : 3.33\n\n\n\nVous √™tes maintenant un pro des commentaires et de l‚Äôaffichage ! Cliquez-ici pour passer √† la suite."
  },
  {
    "objectID": "struct_controle.html",
    "href": "struct_controle.html",
    "title": "Structures de contr√¥le",
    "section": "",
    "text": "Les op√©rateurs\n\nLes op√©rateurs de comparaison\n\nLes op√©rateurs Python sont essentiels pour effectuer des op√©rations sur les variables et les valeurs. Parmi eux, les op√©rateurs de comparaison sont particuli√®rement utiles, permettant de comparer des valeurs et des variables selon diff√©rentes conditions telles que √©gal √† (==), diff√©rent de (!=), sup√©rieur √† (&gt;), inf√©rieur √† (&lt;), sup√©rieur ou √©gal √† (&gt;=), et inf√©rieur ou √©gal √† (&lt;=). Ces op√©rateurs sont fondamentaux pour la logique conditionnelle et les structures de contr√¥le dans les programmes Python.\n\n\nCes op√©rateurs renvoient soit Vrai (True) soit Faux (False) selon le r√©sultat de la comparaison.\n\n\n\n\nOp√©rateur\nDescription\n\n\n\n\n==\n√©gal √†\n\n\n!=\ndiff√©rent de\n\n\n&gt;\nsup√©rieur √†\n\n\n&lt;\ninf√©rieur √†\n\n\n&gt;=\nsup√©rieur ou √©gal √†\n\n\n&lt;=\ninf√©rieur ou √©gal √†\n\n\n\n\n\nLes op√©rateurs logiques\n\nLes op√©rateurs logiques et (and), ou (or) et non (not) sont √©galement tr√®s utiles pour combiner des conditions notamment avec des op√©rateurs de comparaison.\n\n\n\n\n\n\n\n\nOp√©rateur\nDescription\n\n\n\n\nand\nRetourne True si les deux op√©randes sont vrais, sinon False.\n\n\nor\nRetourne True si au moins un des op√©randes est vrai, sinon False.\n\n\nnot\nRetourne True si l‚Äôop√©rande est faux, sinon False.\n\n\n\n\n\nLes op√©rateurs d‚Äôappartenance\n\nLes op√©rateurs d‚Äôappartenance in et not in sont √©galement tr√®s utiles pour v√©rifier si une valeur ou une variable est incluse dans une autre valeur ou variable\n\n\n\n\n\n\n\n\nOp√©rateur\nDescription\n\n\n\n\nin\nRetourne True si l‚Äô√©l√©ment est pr√©sent dans la s√©quence, sinon False.\n\n\nnot in\nRetourne True si l‚Äô√©l√©ment n‚Äôest pas pr√©sent dans la s√©quence, sinon False.\n\n\n\n\n\n\nLes conditions\n\nLes conditions en Python permettent d‚Äôex√©cuter certaines parties du code uniquement si une condition sp√©cifique est remplie. Elles sont souvent utilis√©es pour prendre des d√©cisions dans le code, en fonction de l‚Äô√©tat ou de la valeur des variables.\nEn Python, les conditions sont g√©n√©ralement exprim√©es √† l‚Äôaide de l‚Äôinstruction if (Si), qui est suivie d‚Äôune expression conditionnelle. Voici un exemple simple :\n\n\na,b = 5,3 # On initialise les variables a et b √† 5 et 3\nif a &gt; b: # Si a est sup√©rieur √† b alors on affiche le message\n    print(\"C'est vrai !\")\n\nC'est vrai !\n\n\n\nDans cet exemple, la condition a &gt; b est √©valu√©e. Si elle est vraie, le code suivant est ex√©cut√©. Si elle est fausse, le code sera ignor√© et le programme continuera √† la prochaine instruction.\n\n\nIl est possible de combiner plusieurs conditions en utilisant les op√©rateurs logiques et de comparaison\n\n\nif a &lt; b or b &lt; 4: # Si a est inf√©rieur √† b ou b est inf√©rieur √† 4 alors on affiche le message\n    print(\"C'est vrai !\")\n\nC'est vrai !\n\n\n\nEn plus de l‚Äôinstruction if (Si), Python propose √©galement d‚Äôautres instructions de contr√¥le de flux, telles que else (Sinon) et elif (abr√©viation de ‚Äúelse if‚Äù pour Sinon Si), pour g√©rer diff√©rents sc√©narios. Voici un exemple utilisant else.\n\n\nx = 10\n\nif x &gt; 10: # Si x est sup√©rieur √† 10 alors on affiche le message suivant\n    print(\"x est sup√©rieur √† 10\")\nelse: # Sinon on affiche le message suivant\n    print(\"x est inf√©rieur √† 10\")\n\nx est inf√©rieur √† 10\n\n\n\nVoici un nouvel exemple qui utilise √† la fois if, else et elif\n\n\na,b,c,d = 20,18,7,10\n\nif a &gt; b and c &gt; d: # Si a est sup√©rieur √† b et c est sup√©rieur √† d alors on affiche le message\n    print(\"a est sup√©rieur √† b et c est sup√©rier √† d\")\nelif a &gt; b and c &lt; d: # Sinon si a est sup√©rieur √† b et c est inf√©rieur √† d alors on affiche le message\n    print(\"a est sup√©rieur √† b et c est inf√©rieur √† d\")\nelse: # Sinon on affiche le message\n    print(\"a est inf√©rieur √† b et c est inf√©rieur √† d\")\n\na est sup√©rieur √† b et c est inf√©rieur √† d\n\n\n\nCombiner ces conditions permet de cr√©er des conditions complexes et de g√©rer des cas plus difficiles.\n\n\n\nLes boucles\n\nLa boucle for\n\nLa boucle for en Python est largement utilis√©e pour parcourir des structures de donn√©es telles que les listes, les tuples, les cha√Ænes de caract√®res ou les dictionnaires. Elle commence par examiner le premier √©l√©ment de la s√©quence sp√©cifi√©e, ex√©cute des actions dans son corps, puis passe √† l‚Äô√©l√©ment suivant jusqu‚Äô√† ce que la s√©quence soit enti√®rement parcourue. La syntaxe de la boucle for comprend le mot-cl√© ‚Äúfor‚Äù, suivi d‚Äôune variable temporaire pour contenir chaque √©l√©ment, du mot-cl√© ‚Äúin‚Äù, de la s√©quence √† parcourir, et enfin de deux points ‚Äú:‚Äù. √Ä l‚Äôint√©rieur du corps de la boucle, vous pouvez appliquer des op√©rations sur la variable temporaire pour effectuer diverses actions. Il est √©galement possible d‚Äôimbriquer des boucles for pour parcourir des structures de donn√©es imbriqu√©es. Lors de l‚Äôit√©ration sur un dictionnaire, vous pouvez utiliser la m√©thode items() pour boucler √† la fois sur les cl√©s et les valeurs associ√©es. Voici plusieurs exemples de boucle for :\n\n\nParcourir une chaine de caract√®res\n\n\nchaine = \"M√©nyssa\"\n\nfor lettre in chaine: # On parcourt la cha√Æne de caract√®re\n    print(lettre) # On affiche chaque lettre\n\nM\n√©\nn\ny\ns\ns\na\n\n\n\nParcourir une liste\n\n\nmaListe = [\"Janvier\", \"F√©vrier\", \"Mars\", \"Avril\"]\n\nfor mois in maListe: # On parcourt la liste\n    print(mois) # On affiche chaque √©l√©ment de la liste\n\nJanvier\nF√©vrier\nMars\nAvril\n\n\n\nMais les boucles ne sont pas simplement faites pour afficher le contenu d‚Äôune s√©quence elles peuvent √™tre combin√©es √† une condition :\n\n\nnombres = [1, 5, 4, 9, 36, 43]\n\nfor nombre in nombres:\n    if nombre % 2 == 0: # Si le nombre est pair\n        print(f\"{nombre} est pair\")\n    else:\n        print(f\"{nombre} est impair\")\n\n1 est impair\n5 est impair\n4 est pair\n9 est impair\n36 est pair\n43 est impair\n\n\n\n\nLa boucle while\n\nLa boucle while permet de r√©p√©ter une partie de code tant qu‚Äôune condition est remplie. Comme son nom l‚Äôindique la boucle while ne s‚Äôarr√™te pas sauf si la condition est remplie, il faut donc √™tre attentif et ne pas faire de boucle while infinie !! Nous allons voir un exemple :\n\n\nnombre = 0\nwhile nombre &lt;= 10: # Tant que nombre est inf√©rieur √† 10\n    print(nombre)\n    nombre+=1\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\nCertaines instructions permettent de modifier le comportement de l‚Äôex√©cution du code au sein d‚Äôune boucle\n\n\n\nbreak : L‚Äôinstruction break est utilis√©e pour sortir pr√©matur√©ment d‚Äôune boucle, interrompant son ex√©cution m√™me si la condition de la boucle while ou la fin de la s√©quence for n‚Äôa pas √©t√© atteinte. Cela est souvent utile lorsque vous avez atteint une condition sp√©cifique et souhaitez arr√™ter la boucle.\n\n\n\n\ncontinue : L‚Äôinstruction continue est utilis√©e pour passer √† l‚Äôit√©ration suivante d‚Äôune boucle sans ex√©cuter le reste du code dans le bloc de la boucle pour l‚Äôit√©ration actuelle. Elle est g√©n√©ralement utilis√©e pour ignorer certaines it√©rations bas√©es sur une condition particuli√®re, tout en continuant √† it√©rer sur le reste des √©l√©ments.\n\n\n\nVoici quelques exemples :\n\n\n# Boucle while avec break\n\ni = 0\nwhile i &lt;= 5:\n    print(i)\n    if i == 3:\n        print(\"Sortie de la boucle car i = 3\")\n        break  # Sort de la boucle si i est √©gal √† 3\n    i += 1\n\n0\n1\n2\n3\nSortie de la boucle car i = 3\n\n\n\n# Boucle while avec continue\ni = 0\nwhile i &lt; 10:\n    i += 1\n    if i == 3:\n        continue  # Passe √† l'it√©ration suivante si i est √©gal √† 3\n    print(i)\n\n1\n2\n4\n5\n6\n7\n8\n9\n10\n\n\n\nC‚Äôen est fini avec les structures de contr√¥le ! Pr√™t pour de nouveaux d√©fis ?Cliquez-ici pour passer √† la suite."
  },
  {
    "objectID": "types_donnees.html",
    "href": "types_donnees.html",
    "title": "Types de donn√©es",
    "section": "",
    "text": "Types de Donn√©es (Structures s√©quentielles)\n\nChaque type de donn√©es s√©quentielles offre des caract√©ristiques distinctes et des utilisations sp√©cifiques, permettant une grande souplesse dans le traitement des donn√©es. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilit√© et leurs capacit√©s de stockage dynamique, les rendant particuli√®rement populaires dans de nombreux sc√©narios d‚Äôutilisation.\n\n\nLes Chaines de Caract√®res\n\nLes cha√Ænes de caract√®res (str) sont utilis√©es pour stocker et manipuler du texte. Elles peuvent √™tre d√©finies en encadrant le texte entre des guillemets simples (‚Äò‚Ä¶‚Äô), doubles (‚Äú‚Ä¶‚Äù), ou triples (‚Äô‚Äô‚Äò‚Ä¶‚Äô‚Äô‚Äô ou ‚Äú‚Äú‚Äú‚Ä¶‚Äù‚Äú‚Äú) pour les cha√Ænes multilignes.  Les cha√Ænes sont des s√©quences de caract√®res index√©es √† partir de 0 et peuvent contenir des caract√®res sp√©ciaux, comme des guillemets, gr√¢ce aux caract√®res d‚Äô√©chappement (). Les cha√Ænes de caract√®res offrent une gamme compl√®te de m√©thodes pour le traitement de texte, les rendant extr√™mement polyvalentes et indispensables pour une vari√©t√© d‚Äôapplications, de manipulations de base √† des op√©rations plus complexes. Voici quelques exemples :\n\n\n# Exemples de chaines de caract√®res\n# Chaine de caract√®res simple\nmaChaine = 'Python est un langage de programmation'\n\n# Chaine de caract√®res double\nmaChaine2 = \"Python est un langage de programmation\"\n\n# Chaine avec un caract√®re d'√©chappement\nmaChaine3 = 'Python c\\'est trop bien'\n\nprint(maChaine)\nprint(maChaine2)\nprint(maChaine3)\n\n# On peut acc√©der √† des √©l√©ments\n# Premier caract√®re\npremierCaractere = maChaine[0] # 'P'\n# Dernier caract√®re\ndernierCaractere = maChaine[-1] # 'n'\n\nPython est un langage de programmation\nPython est un langage de programmation\nPython c'est trop bien\n\n\n\nLes m√©thodes sont des fonctions associ√©es √† des objets sp√©cifiques, leur permettant d‚Äôex√©cuter des actions sur ces objets ou de manipuler leurs donn√©es internes. Contrairement aux fonctions ind√©pendantes, les m√©thodes sont li√©es √† des objets particuliers.  Par exemple, les m√©thodes des cha√Ænes de caract√®res (str) sont con√ßues pour op√©rer sur des cha√Ænes de caract√®res sp√©cifiques. Elles sont appel√©es en utilisant la notation point√©e, comme objet.methode(). Les m√©thodes de cha√Ænes de caract√®res incluent des fonctionnalit√©s telles que upper(), lower(), et replace(), permettant de convertir en majuscules, en minuscules ou de remplacer des parties sp√©cifiques de la cha√Æne. Pour appeler une m√©thode, utilisez g√©n√©ralement la syntaxe objet.methode(arguments).  Pour utiliser ces m√©thodes vous pouvez les utiliser sur des variables contenant une chaine de caract√®res ou sur des chaines de caract√®res directement.\n\n\n# M√©thodes pour les cha√Ænes de caract√®res\n\n# isupper() et islower()\n\nchaineMaj = \"PYTHON\"\nchaineMin = \"python\"\nestMajuscule = chaineMaj.isupper()\nestMinuscule = chaineMin.islower()\nprint(estMajuscule) # R√©sultat : True\nprint(estMinuscule) # R√©sultat : True\n\n# upper() et lower()\nchaine = \"python est g√©nial\"\nminToMaj = chaine.upper()\nprint(minToMaj) # R√©sultat : \"PYTHON EST G√âNIAL\"\n\nmajToMin = \"PYTHON est G√âNIAL\".lower()\nprint(majToMin) # R√©sultat : \"python est g√©nial\"\n\nchaineCapitalize = chaine.capitalize() # La premi√®re lettre est en majuscule\nprint(chaineCapitalize) # R√©sultat : \"Python est g√©nial\"\n\nchaineTitle = chaine.title() # La premi√®re lettre de chaque mot est en majuscule\nprint(chaineTitle) # R√©sultat : \"Python Est G√©nial\"\n\nposition = chaine.find(\"est\") # La m√©thode find() renvoie l'index de la premi√®re occurrence de la cha√Æne recherch√©e\nprint(position) # R√©sultat : 7\n\nchaineReplace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\") # La m√©thode replace() remplace une cha√Æne par une autre\nprint(chaineReplace) # R√©sultat : \"Les bananes sont rouges.\"\n\nchaineSplit = chaine.split(\" \") # La m√©thode split() d√©coupe une cha√Æne en une liste de sous-cha√Ænes\nprint(chaineSplit) # R√©sultat : [\"python\", \"est\", \"genial\"]\n\nelements = [\"apple\", \"orange\", \"banana\"]\ntextJoin = \", \".join(elements) # La m√©thode join() concat√®ne les √©l√©ments d'une liste\nprint(textJoin) # R√©sultat : \"apple, orange, banana\"\n\ntextStrip = \" Bonjour \".strip() # La m√©thode strip() supprime les espaces en d√©but et fin de cha√Æne\nprint(textStrip) # R√©sultat : \"Bonjour\"\n\nchaineStartsWith = chaine.startswith(\"Python\")\nprint(chaineStartsWith) # R√©sultat : True\n\nchaineEndsWith = chaine.endswith(\"g√©nial\")\nprint(chaineEndsWith) # R√©sultat : True\n\nTrue\nTrue\nPYTHON EST G√âNIAL\npython est g√©nial\nPython est g√©nial\nPython Est G√©nial\n7\nLes bananes sont rouges.\n['python', 'est', 'g√©nial']\napple, orange, banana\nBonjour\nFalse\nTrue\n\n\n\n\nLes listes\n\nLes listes repr√©sentent des structures de donn√©es permettant de stocker une s√©quence d‚Äô√©l√©ments. Elles offrent une grande souplesse, car elles peuvent contenir des √©l√©ments de types vari√©s et sont modifiables. En tant que collections ordonn√©es, les √©l√©ments sont organis√©s de mani√®re s√©quentielle, s√©par√©s par des virgules et envelopp√©s entre crochets pour les chaines de caract√®res. Pour cr√©er une liste, il suffit d‚Äôencadrer une s√©rie d‚Äô√©l√©ments avec des crochets, s√©par√©s par des virgules, par exemple : [‚ÄúBonjour‚Äù, ‚ÄúAu revoir‚Äù, 75]. L‚Äôacc√®s aux √©l√©ments se fait en utilisant leur index, en commen√ßant par 0. √âtant donn√© que les listes sont mutables, il est possible de modifier leurs √©l√©ments apr√®s leur cr√©ation.\n\n\n# D√©finition d'une liste\nmaListe = [1, 2, 3, \"a\", \"b\", \"c\"]\nprint(maListe)\n\n# Acc√®s au premier et au dernier √©l√©ment\npremierElement = maListe[0]\ndernierElement = maListe[-1]\nprint(premierElement, \"\\n\", dernierElement)\n\n# Modification du deuxi√®me √©l√©ment\nmaListe[1] = \"deux\" \nprint(maListe)\n\n# Concat√©nation et R√©p√©tition\ncombinee = maListe + [\"autre\", \"liste\"]\nprint(combinee)\n\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n[1, 2, 3, 'a', 'b', 'c']\n1 \n c\n[1, 'deux', 3, 'a', 'b', 'c']\n[1, 'deux', 3, 'a', 'b', 'c', 'autre', 'liste']\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\nLe Slicing\n\nEn plus de permettre l‚Äôacc√®s aux √©l√©ments d‚Äôune liste un par un, Python propose une syntaxe concise appel√©e slicing pour acc√©der aux sous-listes.\n\n\n# D√©finition d'une liste\nmaListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers\n\n# Acc√®s √† une sous-liste en utilisant le slicing\nsousListe1 = maListe[1:3]  # R√©cup√®re les √©l√©ments de l'index 1 inclus jusqu'√† l'index 3 non inclus\nsousListe2 = maListe[:3]   # R√©cup√®re les trois premiers √©l√©ments de la liste\nsousListe3 = maListe[2:]   # R√©cup√®re les √©l√©ments √† partir de l'index 2 jusqu'√† la fin de la liste\nsousListe4 = maListe[::2]  # R√©cup√®re les √©l√©ments avec un pas de 2\n\n# Affichage des sous-listes\nprint(\"Sous-liste 1:\", sousListe1)  # R√©sultat : [1, 2]\nprint(\"Sous-liste 2:\", sousListe2)  # R√©sultat : [0, 1, 2]\nprint(\"Sous-liste 3:\", sousListe3)  # R√©sultat : [2, 3, 4]\nprint(\"Sous-liste 4:\", sousListe4)  # R√©sultat : [0, 2, 4]\n\n# Exemples de mutations de listes :\n\n# Cas 1: source de m√™me longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]  # Remplace la sous-liste √† partir de l'index 1 par [4, 5]\nprint(nums1)  # R√©sultat : [1, 4, 5]\n\n# Cas 2: source de longueur diff√©rente\nnums2 = nums1\nnums2[1:] = [6]  # Remplace la sous-liste √† partir de l'index 1 par [6]\nprint(nums2)  # R√©sultat : [1, 6]\n\n# V√©rification si les deux listes pointent vers le m√™me objet en m√©moire\nisSameObject = id(nums1) == id(nums2)  # V√©rifie si les listes pointent vers le m√™me objet\nprint(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifi√©es en place\n\nSous-liste 1: [1, 2]\nSous-liste 2: [0, 1, 2]\nSous-liste 3: [2, 3, 4]\nSous-liste 4: [0, 2, 4]\n[1, 4, 5]\n[1, 6]\nTrue\n\n\n\n\nLes m√©thodes de listes\n\nChaque m√©thode offre une fonctionnalit√© unique pour manipuler des listes, rendant ces structures de donn√©es extr√™mement flexibles et puissantes pour une vari√©t√© de t√¢ches en programmation Python.\n\n\n\n\n\n\n\n\n\nM√©thode\nDescription\nExemple d‚ÄôUtilisation\n\n\n\n\nappend()\nAjoute un √©l√©ment √† la fin de la liste.\nliste.append(5)\n\n\nextend()\n√âtend la liste en ajoutant tous les √©l√©ments d‚Äôune autre liste.\nliste.extend([6, 7])\n\n\ninsert()\nIns√®re un √©l√©ment √† une position donn√©e.\nliste.insert(1, ‚Äòa‚Äô)\n\n\nremove()\nSupprime la premi√®re occurrence d‚Äôun √©l√©ment.\nliste.remove(‚Äòa‚Äô)\n\n\npop()\nSupprime et renvoie un √©l√©ment √† une position donn√©e (par d√©faut, le dernier).\nliste.pop()\n\n\nclear()\nSupprime tous les √©l√©ments de la liste.\nliste.clear()\n\n\nindex()\nRetourne l‚Äôindice du premier √©l√©ment correspondant.\nliste.index(‚Äòa‚Äô)\n\n\ncount()\nCompte le nombre d‚Äôoccurrences d‚Äôun √©l√©ment sp√©cifique.\nliste.count(5)\n\n\nsort()\nTrie les √©l√©ments de la liste (dans un ordre sp√©cifique).\nliste.sort()\n\n\nreverse()\nInverse l‚Äôordre des √©l√©ments de la liste.\nliste.reverse()\n\n\n\n\n# Cr√©ation d'une liste de base\nmaListe = [1, 2, 3]\nprint(maListe)\n\n# Ajout d'un √©l√©ment √† la fin de la liste avec append()\nmaListe.append(\"quatre\")\nprint(\"Apr√®s append(quatre):\", maListe)\n\n# Extension de la liste en ajoutant les √©l√©ments d'une autre liste avec extend()\nmaListe.extend([5, 6])\nprint(\"Apr√®s extend([5, 6]):\", maListe)\n\n# Insertion d'un √©l√©ment √† un index sp√©cifique avec insert()\nmaListe.insert(1, 'elephant')\nprint(\"Apr√®s insert(1, 'elephant'):\", maListe)\n\n# Suppression de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec remove()\nmaListe.remove('elephant')\nprint(\"Apr√®s remove('elephant'):\", maListe)\n\n# Suppression et retour de l'√©l√©ment √† la fin de la liste avec pop()\nelementSupprime = maListe.pop()\nprint(\"Apr√®s pop():\", maListe, \", √âl√©ment supprim√©:\", elementSupprime)\n\n# Suppression de tous les √©l√©ments de la liste avec clear()\nmaListe.clear()\nprint(\"Apr√®s clear():\", maListe)\n\n# Recr√©ation de la liste pour les autres m√©thodes\nmaListe = [3, 1, 4, 2, 2]\n\n# Recherche de l'index de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec index()\nindexDe4 = maListe.index(4)\nprint(\"Index de 4:\", indexDe4)\n\n# Comptage du nombre d'occurrences d'un √©l√©ment sp√©cifi√© avec count()\ncompteDe2 = maListe.count(2)\nprint(\"Nombre d'occurrences de 2:\", compteDe2)\n\n# Tri des √©l√©ments de la liste dans l'ordre croissant avec sort()\nmaListe.sort()\nprint(\"Apr√®s sort():\", maListe)\n\n# Inversion de l'ordre des √©l√©ments dans la liste avec reverse()\nmaListe.reverse()\nprint(\"Apr√®s reverse():\", maListe)\n\n[1, 2, 3]\nApr√®s append(quatre): [1, 2, 3, 'quatre']\nApr√®s extend([5, 6]): [1, 2, 3, 'quatre', 5, 6]\nApr√®s insert(1, 'elephant'): [1, 'elephant', 2, 3, 'quatre', 5, 6]\nApr√®s remove('elephant'): [1, 2, 3, 'quatre', 5, 6]\nApr√®s pop(): [1, 2, 3, 'quatre', 5] , √âl√©ment supprim√©: 6\nApr√®s clear(): []\nIndex de 4: 2\nNombre d'occurrences de 2: 2\nApr√®s sort(): [1, 2, 2, 3, 4]\nApr√®s reverse(): [4, 3, 2, 2, 1]\n\n\n\n\nParcours de liste\n\nLe parcours de liste consiste √† acc√©der s√©quentiellement √† chaque √©l√©ment d‚Äôune liste. Cela peut √™tre fait de diff√©rentes mani√®res, mais les plus courantes sont les boucles for et while .\n\n\nBoucle for : : La boucle for est la m√©thode la plus couramment utilis√©e pour parcourir une liste. Elle permet de traiter chaque √©l√©ment individuellement.\nList Comprehension : La compr√©hension de liste est une m√©thode concise pour cr√©er des listes. Elle permet de transformer une liste en une autre liste, en filtrant les √©l√©ments pour former une liste des r√©sultats d‚Äôune expression donn√©e\n\n\nLa syntaxe de base d‚Äôune compr√©hension de liste est : [nouvelle_expression for item in iterable if condition**]\n\n\n\nnouvelle_expression est l‚Äôexpression qui d√©finit comment mapper les √©l√©ments de l‚Äô iterable (par exemple, une liste).\n\n\n\n\nitem est la variable qui prend la valeur de chaque √©l√©ment de l‚Äô iterable pendant chaque it√©ration.\n\n\n\n\ncondition est une condition optionnelle pour filtrer les √©l√©ments de l‚Äô iterable.\n\n\n\n\nNous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une list comprehension :\n\n\n# r√©cup√©rer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nautreListe = []\nautreListe2 = []\n\n# Avec une boucle for\nfor f in fruits:\n    if \"a\" in f:\n        autreListe.append(f)\nprint(autreListe)\n\n# Avec une list comprehension\nautreListe2 = [f for f in fruits if \"a\" in f ]\nprint(autreListe2)\n\n['apple', 'banana', 'mango']\n['apple', 'banana', 'mango']\n\n\n\nNous pouvons voir que les list comprehension sont un moyen d‚Äô√©crire un code plus concis mais toujours autant compr√©hensible ! Alors pourquoi se prendre la t√™te avec une boucle for ? üòé  Elles peuvent aussi √™tre utilis√©es pour effectuer des calculs sur tous les √©l√©ments d‚Äôune liste. Voyons √ßa :\n\n\n# Elevation des nombres d'une liste au carr√©\nnombres = [2, 5, 10, 111]\nnombreCarres = [x**2 for x in nombres]\nprint(nombreCarres) # [4, 25, 100, 12321]\n\n# Filtrer les nombres pairs d'une liste\ncarresPairs = [x for x in nombreCarres if x%2==0]\nprint(carresPairs)\n\n# Appliquer une m√©thode √† tous les √©l√©ments\nfruits_majuscule = [fruit.upper() for fruit in fruits]\nprint(fruits_majuscule)\n\n[4, 25, 100, 12321]\n[4, 100]\n['APPLE', 'BANANA', 'CHERRY', 'KIWI', 'MANGO']\n\n\n\n\n\nLes tuples\n\nLes tuples sont des listes non mutables. Cela signifie que les √©l√©ments d‚Äôun tuple ne peuvent pas √™tre modifi√©s apr√®s cr√©ation. Les √©l√©ments sont s√©par√©s par d√© virgules et sont entour√©s de parenth√®ses.\n\n\n\n\n\n\n\n\nAvantage\nDescription\n\n\n\n\nS√©curit√© des Donn√©es\nParfait pour prot√©ger les donn√©es contre les modifications.\n\n\nPerformance\nPlus rapides √† parcourir que les listes.\n\n\nUtilisation en tant que Cl√©s de Dictionnaire\nPeuvent √™tre utilis√©s comme cl√©s dans les dictionnaires, contrairement aux listes.\n\n\nRetour de Plusieurs Valeurs de Fonction\nUtilis√©s pour retourner plusieurs valeurs depuis une fonction.\n\n\nStockage de Donn√©es Constantes\nId√©aux pour stocker des donn√©es qui ne doivent pas √™tre modifi√©es.\n\n\n\n\n# D√©finition d'un tuple\nmonTuple = (10, \"b\", 3.14)\nprint(monTuple)\n\nunAutreTuple = 20, \"c\", 4.28\nprint(unAutreTuple)\n\nelementIndex1 = monTuple[1]\nprint(elementIndex1)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = 50,\nprint(tupleSingleton)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = (50,)\n\n# Imbrication\ntupleImbrique = (10, (20, 30), (40, 50))\n\n# M√©thodes Utiles\nlongueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3\nprint(longueur)\n\ncompteur = monTuple.count(\"b\")  # Compte le nombre de fois que \"b\" appara√Æt dans monTuple, ici 1\nprint(compteur)\n\nindice = monTuple.index(\"b\")  # Trouve l'indice de \"b\" dans monTuple, ici 1\nprint(indice)\n\n# L'affectation n'est pas possible\n# monTuple[1] = \"c\"\n\n(10, 'b', 3.14)\n(20, 'c', 4.28)\nb\n(50,)\n3\n1\n1\n\n\n\n\nLes ensembles\n\nLes ensembles sont :\n\n\nDes collections non ordonn√©es de valeurs uniques\nMutables, mais chaque √©l√©ment doit √™tre unique.\nNon-Ordonn√©s : Les ensembles ne maintiennent pas l‚Äôordre des √©l√©ments. On ne peut donc pas acc√©der aux √©l√©ments par un index.\nLes √©l√©ments sont s√©par√©s par des virgules, et encadr√©s par des accolades\n\n\nOp√©rations sur les ensembles\n\n\n\n\n\n\n\n\nOp√©ration\nSyntaxe\nDescription\n\n\n\n\nUnion\na | b\nRetourne un nouvel ensemble contenant tous les √©l√©ments uniques des ensembles a et b.\n\n\nIntersection\na & b\nRetourne un nouvel ensemble contenant uniquement les √©l√©ments communs aux ensembles a et b.\n\n\nDiff√©rence\na - b\nRetourne un nouvel ensemble contenant les √©l√©ments de a qui ne sont pas dans b.\n\n\nDiff√©rence Sym√©trique\na ^ b\nRetourne un nouvel ensemble contenant tous les √©l√©ments qui sont dans a ou b, mais pas dans les deux.\n\n\nAjout\na.add(x)\nAjoute l‚Äô√©l√©ment x √† l‚Äôensemble a.\n\n\nSuppression\na.remove(x)\nSupprime l‚Äô√©l√©ment x de l‚Äôensemble a ; l√®ve une erreur si x n‚Äôest pas pr√©sent.\n\n\nSuppression (sans erreur)\na.discard(x)\nSupprime l‚Äô√©l√©ment x de l‚Äôensemble a si x est pr√©sent ; ne fait rien sinon.\n\n\n\n\n\n\nLes dictionnaires\n\nLes dictionnaires sont un peu comme un format de JSON :\n\n\nIls sont bas√©s sur des paires cl√©s-valeurs\nOn acc√®de aux valeurs via les cl√©s\nIls sont mutables, on peut y ajouter des √©l√©ments, en supprimer ou en modifier\n\nUtilisation :\nStockage d‚ÄôInformations Structur√©es : Parfait pour stocker des informations complexes comme des donn√©es utilisateur.\nRecherche Rapide : Utilisez des dictionnaires pour des recherches rapides bas√©es sur des cl√©s uniques\n\n\nIl existe des m√©thodes li√©es aux variables de type dictionnaire pour les manier :\n\n\n\n\n\n\n\n\nM√©thode\nDescription\n\n\n\n\ndict.keys()\nRetourne une vue sur les cl√©s du dictionnaire.\n\n\ndict.values()\nRetourne une vue sur les valeurs du dictionnaire.\n\n\ndict.items()\nRetourne une vue sur les paires (cl√©, valeur) du dictionnaire.\n\n\ndict.get(key)\nRetourne la valeur associ√©e √† la cl√© sp√©cifi√©e.\n\n\n\nSi la cl√© n‚Äôexiste pas, retourne None ou une valeur par d√©faut sp√©cifi√©e en argument.\n\n\ndict.pop(key)\nRetourne la valeur associ√©e √† la cl√© sp√©cifi√©e et supprime cette paire du dictionnaire.\n\n\n\nSi la cl√© n‚Äôexiste pas, retourne une valeur par d√©faut sp√©cifi√©e en argument ou l√®ve une erreur.\n\n\ndict.popitem()\nRetourne et supprime une paire (cl√©, valeur) arbitraire du dictionnaire.\n\n\ndict.update(other_dict)\nMet √† jour le dictionnaire avec les paires cl√©-valeur du dictionnaire sp√©cifi√© en argument.\n\n\ndict.clear()\nSupprime toutes les paires cl√©-valeur du dictionnaire, le laissant vide.\n\n\n\n\n# Cr√©ation d'un dictionnaire\nindividu = {\"nom\": \"Alice\", \"age\": 30}\nautre_dictionnaire = dict(nom=\"Bob\", age=25)\nindividu\n\n# Ajout et mise √† jour\nindividu[\"profession\"] = \"D√©veloppeur\"\nindividu\n\n# Mise √† jour de plusieurs cl√©s\nindividu.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\nindividu\n\n# Utilisation de keys()\ncles = individu.keys()\nprint(\"Cl√©s:\", cles)\n\n# Utilisation de values()\nvaleurs = individu.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = individu.items()\nprint(\"Paires cl√©-valeur:\", paires)\n\n# Utilisation de get()\nnom_personne = individu.get(\"nom\")\nage_personne = individu.get(\"age\")\nprint(nom_personne, age_personne)\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\"\nville = individu.get(\"ville\")\nville\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\" avec une valeur par d√©faut\nville = individu.get(\"ville\", \"Non sp√©cifi√©e\")\nprint(\"Ville:\", ville)\n\n# Parcours des cl√©s\nprint(\"\\nParcours des cl√©s:\")\nfor cle in individu.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in individu.values():\n    print(valeur)\n\n# Parcours des paires cl√©-valeur\nprint(\"\\nParcours des paires cl√©-valeur:\")\nfor cle, valeur in individu.items():\n    print(cle, \":\", valeur)\n\n# Parcours des paires cl√©-valeur avec enumerate\nprint(\"\\nParcours des paires cl√©-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(individu.items()):\n    print(f\"Index {index}: Cl√© = {cle}, Valeur = {valeur}\")\n\n# Suppression d'une cl√© et de sa valeur\ndel individu[\"age\"]\nprint(individu)\n\n# Suppression d'une cl√© avec retour de sa valeur\nprofession = individu.pop(\"profession\")\nprint(profession)\n\n# Suppression d'une cl√© avec retour de sa valeur et gestion de l'absence de la cl√©\nville_supprimee = individu.pop(\"ville\", \"Non sp√©cifi√©e\")\nprint(ville_supprimee)\n\n# Affichage du dictionnaire apr√®s les suppressions\nprint(individu)\n\nCl√©s: dict_keys(['nom', 'age', 'profession'])\nValeurs: dict_values(['Romain', 30, 'Data Scientist'])\nPaires cl√©-valeur: dict_items([('nom', 'Romain'), ('age', 30), ('profession', 'Data Scientist')])\nRomain 30\nVille: Non sp√©cifi√©e\n\nParcours des cl√©s:\nnom\nage\nprofession\n\nParcours des valeurs:\nRomain\n30\nData Scientist\n\nParcours des paires cl√©-valeur:\nnom : Romain\nage : 30\nprofession : Data Scientist\n\nParcours des paires cl√©-valeur avec enumerate:\nIndex 0: Cl√© = nom, Valeur = Romain\nIndex 1: Cl√© = age, Valeur = 30\nIndex 2: Cl√© = profession, Valeur = Data Scientist\n{'nom': 'Romain', 'profession': 'Data Scientist'}\nData Scientist\nNon sp√©cifi√©e\n{'nom': 'Romain'}\n\n\n\nVous √™tes maintenant des pros des donn√©es s√©quentielles ! Pensez-vous que cela suffit ? Continuez de vous instruire en cliquant ici pour passer √† la suite."
  },
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Les Fonctions",
    "section": "",
    "text": "Les fonctions : D√©finition et rappels\n\nQu‚Äôest ce qu‚Äôune fonction ?\n\nUne fonction en programmation est essentiellement une s√©rie d‚Äôinstructions regroup√©es sous un nom sp√©cifique. Elle agit comme une petite ‚Äúmachine‚Äù qui peut recevoir des entr√©es, appel√©es param√®tres, traiter ces donn√©es selon un ensemble d‚Äôinstructions d√©finies √† l‚Äôint√©rieur de la fonction, et √©ventuellement produire un r√©sultat, appel√© valeur de retour.\n\n\n\nUne fonction en Python\n\nUne fonction est d√©finie en utilisant le mot-cl√© def, suivi du nom de la fonction, des parenth√®ses () contenant des param√®tres (si n√©cessaires), et un bloc d‚Äôinstructions indent√©.\n\n\ndef nom_de_la_fonction(parametres):\n    # instructions\n    return valeur_de_retour\n\n\n\nL‚Äôimportance des fonctions\n\nLes fonctions jouent un r√¥le crucial dans la r√©duction de la redondance du code. Plut√¥t que de r√©p√©ter le m√™me code √† plusieurs endroits, les fonctions nous permettent de regrouper ce code et de l‚Äôappeler selon les besoins. Cette approche rend le code plus concis, plus clair et plus simple √† maintenir.\n\n\n\nPourquoi utiliser les fonctions ?\n\nLes fonctions offrent plusieurs avantages essentiels :\n\n\n\nSimplification du code : En encapsulant des t√¢ches complexes dans des fonctions, on simplifie le code principal, le rendant plus lisible et plus compr√©hensible.\n\n\n\n\nR√©utilisabilit√© : Une fois une fonction d√©finie, elle peut √™tre utilis√©e autant de fois que n√©cessaire sans avoir √† r√©√©crire le m√™me code, ce qui √©conomise du temps et r√©duit les risques d‚Äôerreurs.\n\n\n\n\nMeilleure organisation du code : Les fonctions contribuent √† structurer le code en unit√©s logiques. Chaque fonction a un objectif sp√©cifique, ce qui facilite la compr√©hension du programme dans son ensemble. De plus, cela simplifie le d√©bogage et le test de parties sp√©cifiques du code.\n\n\n\n\n\ndef maFonction():\n    print(\"C'est MA fonction\")\n\n\nDans cet exemple maFonction est le nom de notre fonction, elle ne prend pas de param√®tre. Les instructions que la fonction ex√©cute permettent simplement d‚Äôafficher un message seulement quand on appelle la fonction.\n\n\n\nAppel d‚Äôune fonction\n\nUne fois la fonction d√©finie, celle-ci peut √™tre appel√©e en utilisant son nom suivi de parenth√®ses. Quand elle est appel√©e, les instructions qui la composent sont execut√©s :\n\n\nmaFonction()\n\nC'est MA fonction\n\n\n\n\nParam√®tres et Arguments\n\nLes fonctions peuvent √™tre plus flexibles lorsqu‚Äôelles prennent des param√®tres. Les param√®tres agissent comme des variables dans la d√©finition de la fonction.\n\n\ndef maFonctionAvecParam(param1, param2):\n    print(param1)\n    print(param2)\n\ndef bonjour(prenom):\n    print(f\"Bonjour {prenom}\")\n\nbonjour(\"Pierre\")\n\nBonjour Pierre\n\n\n\nDans l‚Äôexemple ci-dessus prenom est le param√®tre de notre fonction bonjour. Quand la fonction est appel√©e, elle prend un argument, qui est une valeur qui est pass√©e √† la fonction lors de son appel. Ici, notre argument est \"Pierre\"."
  }
]