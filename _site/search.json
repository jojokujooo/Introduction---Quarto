[
  {
    "objectID": "var_ope.html",
    "href": "var_ope.html",
    "title": "Variables et opérations",
    "section": "",
    "text": "Concrètement, les variables sont juste des éléments qui peuvent contenir des données, même si c’est plus compliqué que ça si vous le retenez c’est déjà pas mal. Elles sont déclarées avec le nom de la variable suivi d’un =, puis de leurs valeurs.\n\n\nPar exemple, si je veux créer une variable qui contient le nombre 1, je peux écrire :\n\n\na = 1\na\n\n1\n\n\n\nMais n’oubliez pas, il y a quand même des règles pour nommer les variables : pas de chiffres au début, pas de symboles bizarres, et ne pas mélanger des mots et des chiffres directement.\n\n\nDe plus, il y a différentes manières de nommer une variable, voici des exemples :\n\n\nLe camelCase : Consiste à écrire chaque mot commençant par une majuscule sauf le premier et sans espaces\nLe snake_case : Consiste à écrire chaque mot séparé par un underscore\nLe PascalCase : Consiste à écrire chaque mot commençant par une majuscule et sans espaces\n\n\nmaVariableExemple = 1       # Ceci est une variable écrite en camelCase\n\nma_variable_exemple = 1     # Ceci est une variable écrite en snake_case\n\nMaVariableExemple = 1       # Ceci est une variable écrite en PascalCase\n\n\nIl y a également plusieurs moyens de donner une valeur à une variable, voici les exemples les plus communs :\n\n\n# Voici l'affectation simple\nmaVariable = 5    \n\n# Voici l'affectation par décomposition\nmaVar1, maVar2, maVar3 = \"valeur 1\", \"valeur 2\", \"valeur 3\"\nprint(maVar1, maVar2, maVar3)\n\n# Voici l'affectation de la même valeur à plusieurs variables\nmaVar1 = maVar2 = maVar3 = 20   \nprint(maVar1, maVar2, maVar3)\n\nvaleur 1 valeur 2 valeur 3\n20 20 20\n\n\n\n\n\nIl y a plusieurs types de variables en Python. Les types de variables en Python sont des catégories qui définissent le type de données qu’une variable peut contenir. En Python, nous rencontrons principalement trois types de variables :\n\n\nLes variables numériques : les variables numériques sont des variables qui peuvent contenir des nombres. On peut en trouver de différents types : entiers(int), décimaux(float) et même complexes(complex) (1, 2.5, 4+2j)\nLes variables de chaîne de caractères : Les chaînes de caractères, plus communément appelées “string” sont des variables qui peuvent contenir du texte. Comme “Bonjour” ou même des paragraphes entiers ! La spécificité des string c’est qu’elles peuvent être délimitées par des guillemets simples (’ ‘), doubles (” “) ou triples (’’’ ’’’). La particularité des guillemets triples c’est qu’elles peuvent contenir des sauts de ligne.\nLes variables booléennes : Les variables booléennes sont des variables qui peuvent contenir des valeurs booléennes donc soit vraie (True) soit fausse (False). Elles sont utilisées pour représenter des conditions ou des états logiques.\n\n\nnomSimple = 'Ményssa'\nnomDouble = \"Johann\"\nnomTriple = '''Fré\ndé\nric'''\nage = 22\ntaille = 1.82\nestVrai = True\nestFaux = False\n\nprint(\"La variable nomSimple est de type: \", type(nomSimple))\nprint(\"La variable age est de type: \", type(age))\nprint(\"La variable taille est de type: \", type(taille))\nprint(\"La variable estVrai est de type: \",type(estVrai))\n\nLa variable nomSimple est de type:  &lt;class 'str'&gt;\nLa variable age est de type:  &lt;class 'int'&gt;\nLa variable taille est de type:  &lt;class 'float'&gt;\nLa variable estVrai est de type:  &lt;class 'bool'&gt;\n\n\n\n\n\n\nIl est possible de convertir un type de variable en un autre. Il existe des fonctions appelées cast ou casting. Voici quelques exemples :\n\n\n# Fonctions utilisées : int(), str(), bool(), float()\n# Conversion en entier\n## Depuis une chaine de caractères\nchaine = \"200\"\nchaineEnEntier = int(chaine) # On convertit la chaine en nombre\n\n## Depuis un booléen\nboolEnEntier= int(estVrai) # On convertit le booléen en nombre\n\n## Flottant en nombre\nfloatEnEntier = int(taille) # On convertit le flottant en nombre, il est troncaturé mais pas arrondi\n\n# Conversion en Chaine de Caractères\n## Depuis un entier ou un flottant\nentierEnChaine = str(chaineEnEntier) # On convertit le nombre en chaine\n\n## Depuis un booléen\nboolEnChaine = str(estVrai) # Convertit False en \"False\" et True en \"True\"\n\n# Conversion en booléen\n## Depuis une chaine de caractères\nchaineEnBool = bool(chaine) # Convertit une chaine non-vide en True et une chaine vide en False\n\n## Depuis un nombre\nnombreEnBool = bool(chaineEnEntier) # Convertit 0 en False et tout autre nombre en True\n\n# Conversion en flottant\n## Depuis une chaine de caractères\nchaineEnFlottant = float(chaine) # Convertit une chaine de caractères en flottant\n\n## Depuis un entier\nentierEnFlottant = float(chaineEnEntier) # Convertit 200 en 200.0\n\n## Depuis un booléen\nboolEnFlottant = float(estVrai) # Convertit True en 1.0 et False en 0.0\n\n\n\n\n\nLes opérations arithmétiques sont les mêmes que dans les autres langages. Voici des exemples d’utilisation d’opérations\n\n\n# Addition (+)\nsomme = 6 + 5\n# Soustraction (-)\ndifference = 6 - 5\n\n# Multiplication \nproduit = 6 * 5\n\n# Division (/)\n\nquotient = 6 / 5\n\n# Modulo (%) Permet de calculer le reste d'une division\nreste = 6 % 5\n\n# Puissance(**) Permet d'élever un nombre à une puissance\npuissance = 6 ** 5\n\n\n\n\n\nNous pouvons utiliser certaines opérations sur des chaines de caractères comme :\n\n\nL’addition (+) : Permet de combiener des chaines de caractères\nLa multiplication (*) : Permet de répéter une chaine de caractères le nombre de fois que l’on donne\n\n\nVoici des exemples d’utilisation d’opérations\n\n\n# Addition (+)\nchaine1 = \"Bonjour\"\nchaine2 = \"tout le monde\" \n\nchaineCombinee = chaine1 + chaine2 # Affiche \"Bonjour tout le monde\"\nprint(chaineCombinee)\n# Multiplication (*)\nchaineRepetee = chaine1 * 3 # Affiche \"BonjourBonjourBonjour\"\nprint(chaineRepetee)\n\nBonjourtout le monde\nBonjourBonjourBonjour\n\n\n\n\n\n\nLes opérateurs d’affectations composées sont des opérateurs qui permettent de combiner des opérations arithmétiques et des affectations à des variable. Simplifiant ainsi le code en effectuant une opération sur une variable et en lui réaffectant le résultat en une seule ligne de code.\n\n\nVoici des exemples d’utilisation d’opérateurs d’affectation :\n\n\n# Création / Initialisation de la variable\nnombre = 10\n\n# Opérateur d'affectation combinée\n# Addition et assignation\nnombre += 5 # nombre = nombre + 5\nprint(nombre) # Affiche 15\n\n# Soustraction et assignation\nnombre -= 5 # nombre = nombre - 5\nprint(nombre) # Affiche 10\n\n# Multiplication et assignation\nnombre *= 5 # nombre = nombre * 5\nprint(nombre) # Affiche 50\n\n# Division et assignation\nnombre /= 5 # nombre = nombre / 5\nprint(nombre) # Affiche 10.0\n\n# Division entière et assignation\nnombre //= 2 # nombre = nombre // 2\nprint(nombre) # Affiche 5\n\n# Modulo et assignation\nnombre %= 3 # nombre = nombre % 3\nprint(nombre) # Affiche 2.0\n\n# Puissance et assignation\nnombre **= 2 # nombre = nombre ** 2\nprint(nombre) # Affiche 4.0\n\n15\n10\n50\n10.0\n5.0\n2.0\n4.0\n\n\n\nNous en avons enfin fini avec les variables ! Etes vous prêt pour la suite ? Cliquez-ici pour passer à la suite."
  },
  {
    "objectID": "var_ope.html#les-variables",
    "href": "var_ope.html#les-variables",
    "title": "Variables et opérations",
    "section": "",
    "text": "Concrètement, les variables sont juste des éléments qui peuvent contenir des données, même si c’est plus compliqué que ça si vous le retenez c’est déjà pas mal. Elles sont déclarées avec le nom de la variable suivi d’un =, puis de leurs valeurs.\n\n\nPar exemple, si je veux créer une variable qui contient le nombre 1, je peux écrire :\n\n\na = 1\na\n\n1\n\n\n\nMais n’oubliez pas, il y a quand même des règles pour nommer les variables : pas de chiffres au début, pas de symboles bizarres, et ne pas mélanger des mots et des chiffres directement.\n\n\nDe plus, il y a différentes manières de nommer une variable, voici des exemples :\n\n\nLe camelCase : Consiste à écrire chaque mot commençant par une majuscule sauf le premier et sans espaces\nLe snake_case : Consiste à écrire chaque mot séparé par un underscore\nLe PascalCase : Consiste à écrire chaque mot commençant par une majuscule et sans espaces\n\n\nmaVariableExemple = 1       # Ceci est une variable écrite en camelCase\n\nma_variable_exemple = 1     # Ceci est une variable écrite en snake_case\n\nMaVariableExemple = 1       # Ceci est une variable écrite en PascalCase\n\n\nIl y a également plusieurs moyens de donner une valeur à une variable, voici les exemples les plus communs :\n\n\n# Voici l'affectation simple\nmaVariable = 5    \n\n# Voici l'affectation par décomposition\nmaVar1, maVar2, maVar3 = \"valeur 1\", \"valeur 2\", \"valeur 3\"\nprint(maVar1, maVar2, maVar3)\n\n# Voici l'affectation de la même valeur à plusieurs variables\nmaVar1 = maVar2 = maVar3 = 20   \nprint(maVar1, maVar2, maVar3)\n\nvaleur 1 valeur 2 valeur 3\n20 20 20\n\n\n\n\n\nIl y a plusieurs types de variables en Python. Les types de variables en Python sont des catégories qui définissent le type de données qu’une variable peut contenir. En Python, nous rencontrons principalement trois types de variables :\n\n\nLes variables numériques : les variables numériques sont des variables qui peuvent contenir des nombres. On peut en trouver de différents types : entiers(int), décimaux(float) et même complexes(complex) (1, 2.5, 4+2j)\nLes variables de chaîne de caractères : Les chaînes de caractères, plus communément appelées “string” sont des variables qui peuvent contenir du texte. Comme “Bonjour” ou même des paragraphes entiers ! La spécificité des string c’est qu’elles peuvent être délimitées par des guillemets simples (’ ‘), doubles (” “) ou triples (’’’ ’’’). La particularité des guillemets triples c’est qu’elles peuvent contenir des sauts de ligne.\nLes variables booléennes : Les variables booléennes sont des variables qui peuvent contenir des valeurs booléennes donc soit vraie (True) soit fausse (False). Elles sont utilisées pour représenter des conditions ou des états logiques.\n\n\nnomSimple = 'Ményssa'\nnomDouble = \"Johann\"\nnomTriple = '''Fré\ndé\nric'''\nage = 22\ntaille = 1.82\nestVrai = True\nestFaux = False\n\nprint(\"La variable nomSimple est de type: \", type(nomSimple))\nprint(\"La variable age est de type: \", type(age))\nprint(\"La variable taille est de type: \", type(taille))\nprint(\"La variable estVrai est de type: \",type(estVrai))\n\nLa variable nomSimple est de type:  &lt;class 'str'&gt;\nLa variable age est de type:  &lt;class 'int'&gt;\nLa variable taille est de type:  &lt;class 'float'&gt;\nLa variable estVrai est de type:  &lt;class 'bool'&gt;\n\n\n\n\n\n\nIl est possible de convertir un type de variable en un autre. Il existe des fonctions appelées cast ou casting. Voici quelques exemples :\n\n\n# Fonctions utilisées : int(), str(), bool(), float()\n# Conversion en entier\n## Depuis une chaine de caractères\nchaine = \"200\"\nchaineEnEntier = int(chaine) # On convertit la chaine en nombre\n\n## Depuis un booléen\nboolEnEntier= int(estVrai) # On convertit le booléen en nombre\n\n## Flottant en nombre\nfloatEnEntier = int(taille) # On convertit le flottant en nombre, il est troncaturé mais pas arrondi\n\n# Conversion en Chaine de Caractères\n## Depuis un entier ou un flottant\nentierEnChaine = str(chaineEnEntier) # On convertit le nombre en chaine\n\n## Depuis un booléen\nboolEnChaine = str(estVrai) # Convertit False en \"False\" et True en \"True\"\n\n# Conversion en booléen\n## Depuis une chaine de caractères\nchaineEnBool = bool(chaine) # Convertit une chaine non-vide en True et une chaine vide en False\n\n## Depuis un nombre\nnombreEnBool = bool(chaineEnEntier) # Convertit 0 en False et tout autre nombre en True\n\n# Conversion en flottant\n## Depuis une chaine de caractères\nchaineEnFlottant = float(chaine) # Convertit une chaine de caractères en flottant\n\n## Depuis un entier\nentierEnFlottant = float(chaineEnEntier) # Convertit 200 en 200.0\n\n## Depuis un booléen\nboolEnFlottant = float(estVrai) # Convertit True en 1.0 et False en 0.0\n\n\n\n\n\nLes opérations arithmétiques sont les mêmes que dans les autres langages. Voici des exemples d’utilisation d’opérations\n\n\n# Addition (+)\nsomme = 6 + 5\n# Soustraction (-)\ndifference = 6 - 5\n\n# Multiplication \nproduit = 6 * 5\n\n# Division (/)\n\nquotient = 6 / 5\n\n# Modulo (%) Permet de calculer le reste d'une division\nreste = 6 % 5\n\n# Puissance(**) Permet d'élever un nombre à une puissance\npuissance = 6 ** 5\n\n\n\n\n\nNous pouvons utiliser certaines opérations sur des chaines de caractères comme :\n\n\nL’addition (+) : Permet de combiener des chaines de caractères\nLa multiplication (*) : Permet de répéter une chaine de caractères le nombre de fois que l’on donne\n\n\nVoici des exemples d’utilisation d’opérations\n\n\n# Addition (+)\nchaine1 = \"Bonjour\"\nchaine2 = \"tout le monde\" \n\nchaineCombinee = chaine1 + chaine2 # Affiche \"Bonjour tout le monde\"\nprint(chaineCombinee)\n# Multiplication (*)\nchaineRepetee = chaine1 * 3 # Affiche \"BonjourBonjourBonjour\"\nprint(chaineRepetee)\n\nBonjourtout le monde\nBonjourBonjourBonjour\n\n\n\n\n\n\nLes opérateurs d’affectations composées sont des opérateurs qui permettent de combiner des opérations arithmétiques et des affectations à des variable. Simplifiant ainsi le code en effectuant une opération sur une variable et en lui réaffectant le résultat en une seule ligne de code.\n\n\nVoici des exemples d’utilisation d’opérateurs d’affectation :\n\n\n# Création / Initialisation de la variable\nnombre = 10\n\n# Opérateur d'affectation combinée\n# Addition et assignation\nnombre += 5 # nombre = nombre + 5\nprint(nombre) # Affiche 15\n\n# Soustraction et assignation\nnombre -= 5 # nombre = nombre - 5\nprint(nombre) # Affiche 10\n\n# Multiplication et assignation\nnombre *= 5 # nombre = nombre * 5\nprint(nombre) # Affiche 50\n\n# Division et assignation\nnombre /= 5 # nombre = nombre / 5\nprint(nombre) # Affiche 10.0\n\n# Division entière et assignation\nnombre //= 2 # nombre = nombre // 2\nprint(nombre) # Affiche 5\n\n# Modulo et assignation\nnombre %= 3 # nombre = nombre % 3\nprint(nombre) # Affiche 2.0\n\n# Puissance et assignation\nnombre **= 2 # nombre = nombre ** 2\nprint(nombre) # Affiche 4.0\n\n15\n10\n50\n10.0\n5.0\n2.0\n4.0\n\n\n\nNous en avons enfin fini avec les variables ! Etes vous prêt pour la suite ? Cliquez-ici pour passer à la suite."
  },
  {
    "objectID": "struct_controle.html",
    "href": "struct_controle.html",
    "title": "Structures de contrôle",
    "section": "",
    "text": "Les opérateurs\n\nLes opérateurs de comparaison\n\nLes opérateurs Python sont essentiels pour effectuer des opérations sur les variables et les valeurs. Parmi eux, les opérateurs de comparaison sont particulièrement utiles, permettant de comparer des valeurs et des variables selon différentes conditions telles que égal à (==), différent de (!=), supérieur à (&gt;), inférieur à (&lt;), supérieur ou égal à (&gt;=), et inférieur ou égal à (&lt;=). Ces opérateurs sont fondamentaux pour la logique conditionnelle et les structures de contrôle dans les programmes Python.\n\n\nCes opérateurs renvoient soit Vrai (True) soit Faux (False) selon le résultat de la comparaison.\n\n\n\n\nOpérateur\nDescription\n\n\n\n\n==\négal à\n\n\n!=\ndifférent de\n\n\n&gt;\nsupérieur à\n\n\n&lt;\ninférieur à\n\n\n&gt;=\nsupérieur ou égal à\n\n\n&lt;=\ninférieur ou égal à\n\n\n\n\n\nLes opérateurs logiques\n\nLes opérateurs logiques et (and), ou (or) et non (not) sont également très utiles pour combiner des conditions notamment avec des opérateurs de comparaison.\n\n\n\n\n\n\n\n\nOpérateur\nDescription\n\n\n\n\nand\nRetourne True si les deux opérandes sont vrais, sinon False.\n\n\nor\nRetourne True si au moins un des opérandes est vrai, sinon False.\n\n\nnot\nRetourne True si l’opérande est faux, sinon False.\n\n\n\n\n\nLes opérateurs d’appartenance\n\nLes opérateurs d’appartenance in et not in sont également très utiles pour vérifier si une valeur ou une variable est incluse dans une autre valeur ou variable\n\n\n\n\n\n\n\n\nOpérateur\nDescription\n\n\n\n\nin\nRetourne True si l’élément est présent dans la séquence, sinon False.\n\n\nnot in\nRetourne True si l’élément n’est pas présent dans la séquence, sinon False.\n\n\n\n\n\n\nLes conditions\n\nLes conditions en Python permettent d’exécuter certaines parties du code uniquement si une condition spécifique est remplie. Elles sont souvent utilisées pour prendre des décisions dans le code, en fonction de l’état ou de la valeur des variables.\nEn Python, les conditions sont généralement exprimées à l’aide de l’instruction if (Si), qui est suivie d’une expression conditionnelle. Voici un exemple simple :\n\n\na,b = 5,3 # On initialise les variables a et b à 5 et 3\nif a &gt; b: # Si a est supérieur à b alors on affiche le message\n    print(\"C'est vrai !\")\n\nC'est vrai !\n\n\n\nDans cet exemple, la condition a &gt; b est évaluée. Si elle est vraie, le code suivant est exécuté. Si elle est fausse, le code sera ignoré et le programme continuera à la prochaine instruction.\n\n\nIl est possible de combiner plusieurs conditions en utilisant les opérateurs logiques et de comparaison\n\n\nif a &lt; b or b &lt; 4: # Si a est inférieur à b ou b est inférieur à 4 alors on affiche le message\n    print(\"C'est vrai !\")\n\nC'est vrai !\n\n\n\nEn plus de l’instruction if (Si), Python propose également d’autres instructions de contrôle de flux, telles que else (Sinon) et elif (abréviation de “else if” pour Sinon Si), pour gérer différents scénarios. Voici un exemple utilisant else.\n\n\nx = 10\n\nif x &gt; 10: # Si x est supérieur à 10 alors on affiche le message suivant\n    print(\"x est supérieur à 10\")\nelse: # Sinon on affiche le message suivant\n    print(\"x est inférieur à 10\")\n\nx est inférieur à 10\n\n\n\nVoici un nouvel exemple qui utilise à la fois if, else et elif\n\n\na,b,c,d = 20,18,7,10\n\nif a &gt; b and c &gt; d: # Si a est supérieur à b et c est supérieur à d alors on affiche le message\n    print(\"a est supérieur à b et c est supérier à d\")\nelif a &gt; b and c &lt; d: # Sinon si a est supérieur à b et c est inférieur à d alors on affiche le message\n    print(\"a est supérieur à b et c est inférieur à d\")\nelse: # Sinon on affiche le message\n    print(\"a est inférieur à b et c est inférieur à d\")\n\na est supérieur à b et c est inférieur à d\n\n\n\nCombiner ces conditions permet de créer des conditions complexes et de gérer des cas plus difficiles.\n\n\n\nLes boucles\n\nLa boucle for\n\nLa boucle for en Python est largement utilisée pour parcourir des structures de données telles que les listes, les tuples, les chaînes de caractères ou les dictionnaires. Elle commence par examiner le premier élément de la séquence spécifiée, exécute des actions dans son corps, puis passe à l’élément suivant jusqu’à ce que la séquence soit entièrement parcourue. La syntaxe de la boucle for comprend le mot-clé “for”, suivi d’une variable temporaire pour contenir chaque élément, du mot-clé “in”, de la séquence à parcourir, et enfin de deux points “:”. À l’intérieur du corps de la boucle, vous pouvez appliquer des opérations sur la variable temporaire pour effectuer diverses actions. Il est également possible d’imbriquer des boucles for pour parcourir des structures de données imbriquées. Lors de l’itération sur un dictionnaire, vous pouvez utiliser la méthode items() pour boucler à la fois sur les clés et les valeurs associées. Voici plusieurs exemples de boucle for :\n\n\nParcourir une chaine de caractères\n\n\nchaine = \"Ményssa\"\n\nfor lettre in chaine: # On parcourt la chaîne de caractère\n    print(lettre) # On affiche chaque lettre\n\nM\né\nn\ny\ns\ns\na\n\n\n\nParcourir une liste\n\n\nmaListe = [\"Janvier\", \"Février\", \"Mars\", \"Avril\"]\n\nfor mois in maListe: # On parcourt la liste\n    print(mois) # On affiche chaque élément de la liste\n\nJanvier\nFévrier\nMars\nAvril\n\n\n\nMais les boucles ne sont pas simplement faites pour afficher le contenu d’une séquence elles peuvent être combinées à une condition :\n\n\nnombres = [1, 5, 4, 9, 36, 43]\n\nfor nombre in nombres:\n    if nombre % 2 == 0: # Si le nombre est pair\n        print(f\"{nombre} est pair\")\n    else:\n        print(f\"{nombre} est impair\")\n\n1 est impair\n5 est impair\n4 est pair\n9 est impair\n36 est pair\n43 est impair\n\n\n\n\nLa boucle while\n\nLa boucle while permet de répéter une partie de code tant qu’une condition est remplie. Comme son nom l’indique la boucle while ne s’arrête pas sauf si la condition est remplie, il faut donc être attentif et ne pas faire de boucle while infinie !! Nous allons voir un exemple :\n\n\nnombre = 0\nwhile nombre &lt;= 10: # Tant que nombre est inférieur à 10\n    print(nombre)\n    nombre+=1\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\nCertaines instructions permettent de modifier le comportement de l’exécution du code au sein d’une boucle\n\n\n\nbreak : L’instruction break est utilisée pour sortir prématurément d’une boucle, interrompant son exécution même si la condition de la boucle while ou la fin de la séquence for n’a pas été atteinte. Cela est souvent utile lorsque vous avez atteint une condition spécifique et souhaitez arrêter la boucle.\n\n\n\n\ncontinue : L’instruction continue est utilisée pour passer à l’itération suivante d’une boucle sans exécuter le reste du code dans le bloc de la boucle pour l’itération actuelle. Elle est généralement utilisée pour ignorer certaines itérations basées sur une condition particulière, tout en continuant à itérer sur le reste des éléments.\n\n\n\nVoici quelques exemples :\n\n\n# Boucle while avec break\n\ni = 0\nwhile i &lt;= 5:\n    print(i)\n    if i == 3:\n        print(\"Sortie de la boucle car i = 3\")\n        break  # Sort de la boucle si i est égal à 3\n    i += 1\n\n0\n1\n2\n3\nSortie de la boucle car i = 3\n\n\n\n# Boucle while avec continue\ni = 0\nwhile i &lt; 10:\n    i += 1\n    if i == 3:\n        continue  # Passe à l'itération suivante si i est égal à 3\n    print(i)\n\n1\n2\n4\n5\n6\n7\n8\n9\n10\n\n\n\nC’en est fini avec les structures de contrôle ! Prêt pour de nouveaux défis ?Cliquez-ici pour passer à la suite."
  },
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Les Fonctions",
    "section": "",
    "text": "Les fonctions : Définition et rappels\n\nQu’est ce qu’une fonction ?\n\nUne fonction en programmation est essentiellement une série d’instructions regroupées sous un nom spécifique. Elle agit comme une petite “machine” qui peut recevoir des entrées, appelées paramètres, traiter ces données selon un ensemble d’instructions définies à l’intérieur de la fonction, et éventuellement produire un résultat, appelé valeur de retour.\n\n\n\nUne fonction en Python\n\nUne fonction est définie en utilisant le mot-clé def, suivi du nom de la fonction, des parenthèses () contenant des paramètres (si nécessaires), et un bloc d’instructions indenté.\n\n\ndef nom_de_la_fonction(parametres):\n    # instructions\n    return valeur_de_retour\n\n\n\nL’importance des fonctions\n\nLes fonctions jouent un rôle crucial dans la réduction de la redondance du code. Plutôt que de répéter le même code à plusieurs endroits, les fonctions nous permettent de regrouper ce code et de l’appeler selon les besoins. Cette approche rend le code plus concis, plus clair et plus simple à maintenir.\n\n\n\nPourquoi utiliser les fonctions ?\n\nLes fonctions offrent plusieurs avantages essentiels :\n\n\n\nSimplification du code : En encapsulant des tâches complexes dans des fonctions, on simplifie le code principal, le rendant plus lisible et plus compréhensible.\n\n\n\n\nRéutilisabilité : Une fois une fonction définie, elle peut être utilisée autant de fois que nécessaire sans avoir à réécrire le même code, ce qui économise du temps et réduit les risques d’erreurs.\n\n\n\n\nMeilleure organisation du code : Les fonctions contribuent à structurer le code en unités logiques. Chaque fonction a un objectif spécifique, ce qui facilite la compréhension du programme dans son ensemble. De plus, cela simplifie le débogage et le test de parties spécifiques du code.\n\n\n\n\n\ndef maFonction():\n    print(\"C'est MA fonction\")\n\n\nDans cet exemple maFonction est le nom de notre fonction, elle ne prend pas de paramètre. Les instructions que la fonction exécute permettent simplement d’afficher un message seulement quand on appelle la fonction.\n\n\n\nAppel d’une fonction\n\nUne fois la fonction définie, celle-ci peut être appelée en utilisant son nom suivi de parenthèses. Quand elle est appelée, les instructions qui la composent sont executés :\n\n\nmaFonction()\n\nC'est MA fonction\n\n\n\n\nParamètres et Arguments\n\nLes fonctions peuvent être plus flexibles lorsqu’elles prennent des paramètres. Les paramètres agissent comme des variables dans la définition de la fonction.\n\n\ndef maFonctionAvecParam(param1, param2):\n    print(param1)\n    print(param2)\n\ndef bonjour(prenom):\n    print(f\"Bonjour {prenom}\")\n\nbonjour(\"Pierre\")\n\nBonjour Pierre\n\n\n\nDans l’exemple ci-dessus prenom est le paramètre de notre fonction bonjour. Quand la fonction est appelée, elle prend un argument, qui est une valeur qui est passée à la fonction lors de son appel. Ici, notre argument est \"Pierre\". Dans cet appel, \"Pierre\" est un argument qui est passé à la fonction bonjour . La fonction utilisera la valeur de cet argument lors de son exécution.\nVoici quelques exemples :\n\n\n# Définition de la fonction pour afficher un message\ndef affiche_message(message):\n    print(f\"Message reçu : {message}\")\n\n# Appel de la fonction avec différents messages\naffiche_message(\"Bonjour, comment ça va ?\")\naffiche_message(\"Python, c'est génial !\")\n\n# Définition de la fonction pour additionner deux nombres\ndef additionner(a, b):\n    somme = a + b\n    print(f\"La somme de {a} et {b} est {somme}\")\n\n# Appel de la fonction avec différents arguments\nadditionner(a=5, b=3)\nadditionner(5, 3)\nadditionner(b=10, a=67)\n\n# Définition de la fonction pour diviser deux nombres\ndef division(a, b):\n    quotient = a / b\n    print(f\"Le quotient de {a} et {b} est {quotient}\")\n\n# Appel de la fonction avec différents arguments\ndivision(a=5, b=3)\ndivision(b=3, a=5)\ndivision(3, 5)\ndivision(5, 3)\n\n# Définition de la fonction pour calculer la puissance d'un nombre\ndef puissance(base, exposant):\n    resultat = base ** exposant\n    print(f\"{base} élevé à la puissance {exposant} est égal à {resultat}\")\n\n# Appel de la fonction avec différents arguments\npuissance(exposant=2, base=3)\n\n# Import de la bibliothèque math pour utiliser pi\nimport math\n\n# Définition de la fonction pour calculer le périmètre d'un cercle\ndef perimetre_cercle(rayon):\n    perimetre = 2 * math.pi * rayon\n    print(f\"Le périmètre d'un cercle de rayon {rayon} est {perimetre:.2f}\")\n\n# Appel de la fonction avec différents rayons\nperimetre_cercle(5)\n\nMessage reçu : Bonjour, comment ça va ?\nMessage reçu : Python, c'est génial !\nLa somme de 5 et 3 est 8\nLa somme de 5 et 3 est 8\nLa somme de 67 et 10 est 77\nLe quotient de 5 et 3 est 1.6666666666666667\nLe quotient de 5 et 3 est 1.6666666666666667\nLe quotient de 3 et 5 est 0.6\nLe quotient de 5 et 3 est 1.6666666666666667\n3 élevé à la puissance 2 est égal à 9\nLe périmètre d'un cercle de rayon 5 est 31.42\n\n\n\n\nDifférence entre Paramètres et Arguments\n\n\n\nParamètres : Ce sont les noms des variables définis dans la déclaration de la fonction. Ces paramètres servent de réceptacles pour les valeurs qui seront passées à la fonction lors de son appel. Ils définissent les données que la fonction s’attend à recevoir pour effectuer ses opérations.\n\n\n\n\nArguments : Ce sont les valeurs réelles fournies à la fonction lors de son appel. Ces valeurs correspondent aux paramètres définis dans la fonction. Lorsque la fonction est appelée, les arguments sont assignés aux paramètres correspondants selon leur position ou leur nom, et la fonction les utilise pour effectuer ses calculs ou exécuter ses instructions.\n\n\n\n\n\nValeurs Par Défaut des Paramètres\n\nLes paramètres présents dans les fonctions peuvent avoir une valeur par défaut. Cela signifie que la fonction peut être appelée sans fournir d’arguments ou si les arguments passés ne correspondent pas aux valeurs attendues.\n\n\ndef uneFonctionQuelconque(parametre_1, \n                          parametre_2 = 'kebab'): # On définit un paramètre par défaut\n    print(f\"Mon premier paramètre est : {parametre_1} \\\n         et mon deuxième paramètre est : {parametre_2}\")\n\nuneFonctionQuelconque('pizza') # On appelle la fonction avec un argument\n\nMon premier paramètre est : pizza          et mon deuxième paramètre est : kebab\n\n\n\nDans cet exemple la fonction uneFonctionQuelconque() est appelée avec seulement un argument donc la fonction utilise le paramètre par défaut kebab\n\n\nCela permet donc d’écrire des fonctions plus flexible, et d’éviter des erreurs quand des arguments ne sont pas essentiels. Voici un autre exemple :\n\n\nuneFonctionQuelconque('Un', 'kebab avec Ményssa')\n\nMon premier paramètre est : Un          et mon deuxième paramètre est : kebab avec Ményssa\n\n\n\n\n\nLes types de fonctions\n\nEn Python il y a deux types de fonctions, celles qui renvoient une valeur et celles qui n’en retournent pas :\n\n\n\n\nFonctions Avec Valeur de Retour : Une fonction avec retour (return) renvoie ladite valeur là où la fonction est appelée. Il faut donc penser à assigner ce retour à une variable.\n\n\n\n\nFonctions Sans Valeur de Retour : Une fonction qui ne revoie rien sert à effectuer des instructions comme afficher des messages.\n\n\n\n\ndef uneAutreFonction():\n    return 'Une valeur de retour' # On retourne une valeur\n\nvariable_resultat = uneAutreFonction()\nprint(variable_resultat) # On affiche la valeur retournée\n\nUne valeur de retour\n\n\n\nIl faut aussi savoir que des instructions peuvent être exécutées dans le retour d’une fonction. Une fonction avec une valeur de retour peut aussi afficher des messages sans imputer la valeur de retour. Nous allons voir ensemble des exemples :\n\n\ndef multiplier_par_deux(a, b=2):\n    print(f\"Vous avez multiplié {a} par {b}\") # On affiche un message\n    return a * b # On retourne la valeur de a * b\n\nresultat = multiplier_par_deux(3) # On appelle la fonction avec un argument\nprint(resultat)\n\ndef celius_en_farenheit(temperature_celsius):\n    return (temperature_celsius * 9/5) + 32\n\ntemperature_farenheit = celius_en_farenheit(10)\nprint(f\"Votre température en Farenheit est {temperature_farenheit}°F\")\n\ndef valeur_minimum(a,b):\n    return min(a,b)\n\nresultat = valeur_minimum(4, 50)\nprint(f'La valeur minimum est : {resultat}')\n\nVous avez multiplié 3 par 2\n6\nVotre température en Farenheit est 50.0°F\nLa valeur minimum est : 4\n\n\n\n\nLa portée des variables\n\nLes variables déclarées dans une fonction sont appelées des variables locales elles sont accessibles seulement à l’intérieur d’une fonction. Tandis qu’une variable déclarée en dehors d’une fonction ou autre est appelée variable globale. Un variable globale est utilisée pour partager des donner à plusieurs partie du programme.\n\n\np = 'Miam le kebab' # Ceci est une variable globale\n\ndef une_fonction():\n    p = 'Miam le poulet' # Ceci est une variable locale\n    print(p)\n\nune_fonction()\n\nprint(p)\n\nMiam le poulet\nMiam le kebab\n\n\n\nCet exemple illustre ce principe, ci-dessus nous pouvons voir que nous avons deux variables p. La première est une variable globale et la seconde est une variable locale. La variable locale est utilisée dans la fonction et la variable globale est utilisée en dehors de la fonction. Il faut tout de même faire attention en utilisant les variables globales pour ne pas créer d’erreurs de conception.\n\n\nIl est possible de modifier une variable globale à l’intérieur d’une fonction en utilisant le mot-clé global.\n\n\na = 35\n\ndef fonction_de_fou():\n    global a # On modifie la variable globale\n    a = 'Kebab'\n\nprint(a) # On affiche la variable globale avant modification\nfonction_de_fou()\nprint(a) # On affiche la variable globale après modification\n\n35\nKebab\n\n\n\n\nNombre d’arguments variable\n\nIl est possible de définir une fonction qui prend un nombre d’arguments variable. Pour cela il faut utiliser le mot-clé * devant un paramètre de type liste ou tuple quand on définit la fonction. A noter que pour les paramètres de type dictionnaire il faut utiliser **, ils sont pratiques car ils permettent de définir les clés d’arguments.\n\n\ndef somme(*nombres):\n    somme = 0\n    for nombre in nombres:\n        somme += nombre\n\n    return somme\n\nresultat = somme(10, 20, 30, 40)\nprint(resultat)\n\n\ndef fonction_avec_dictionnaire(**dict):\n    print(f\"Mon prénom est {dict['prenom']}, mon repas préféré est le {dict['repas']}\")\n\nfonction_avec_dictionnaire(prenom = 'Ményssa', repas = 'Kebab')\n\n100\nMon prénom est Ményssa, mon repas préféré est le Kebab\n\n\n\nOn peut aussi accéder à ses arguments avec l’index du paramètre. Attention, il faut être sûrs de passer assez d’arguments à la fonction sinon il y aura une erreur ! Dans le cas inverse, les arguments “en trop” seront ignorés.\n\n\ndef les_parametres(*parametres):\n    print(f\"Message : {parametres[2]}\")\n    return parametres[0] + parametres[1]\n\nles_parametres(1,2, 'Je suis le troisième argument')\n\nMessage : Je suis le troisième argument\n\n\n3\n\n\n\n\nLes fonctions anonymes (Lambda Functions)\n\nLe mot-clé lambda sert à définir des fonctions anonymes, aussi appelées fonctions lambda. Les fonctions lambda ne sont pas définies avec un nom mais peuvent être utilisées dans des expressions ou des fonctions. Elles sont utilisées quand des fonctions simples doivent utilisée pour une tâche spécifique. Par exemple trier une liste de nombre ou appliquer une formule à toute une liste.\n\n\ncelsius_en_farenheit = lambda x: (x*9/5)+32\n\ncelsius_en_farenheit(10)\n\nliste_nombres = range(1,10)\n\n# Eleve les nombres au carré\nnombres_carrés = [(lambda x: x*x)(nombre) for nombre in liste_nombres]\nprint(nombres_carrés)\n\nnombres_pairs = list(filter(lambda x: x%2==0, liste_nombres))\nprint(nombres_pairs)\n\nnombres_carres_map = map(lambda n:n*n, liste_nombres)\nprint(list(nombres_carres_map))\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n[2, 4, 6, 8]\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\n\nComme vu ci-dessus, les fonctions map et filter peuvent être utilisée avec des fonctions lambdas. mappermet d’appliquer une fonction à une variable itérable (liste, tuple, dictionnaire) et filter permet, comme son nom l’indique, de filtrer les éléments d’une liste selon une condition émise dans une fonction lambda.\n\n\n\nLes fonctions et la récursivité\n\nLa récursivité est un principe essentiel en programmation. Cela consiste à définir une fonction qui s’appelle elle-même. Cela peut paraître étrange mais c’est une technique puissante pour résoudre certains problèmes, généralement quand on peut les décomposer en sous-problèmes. Voici des exemples :\n\n\nimport time\ndef compte_a_rebours(temps):\n    if temps &lt;= 0:\n        print(\"C'est l'heure du kebab !\")\n    else:\n        print(temps)\n        time.sleep(1)\n        compte_a_rebours(temps-1)\n\ncompte_a_rebours(5)\n\n5\n4\n3\n2\n1\nC'est l'heure du kebab !\n\n\n\nDans cet exemple, la fonction compte_a_rebours prend un nombre en paramètre. Si il est inférieur ou égal à 0 on affiche le message de fin du compte. Sinon on affiche le temps restant, on attend 1 seconde avec la fonction time.sleep et on appelle la fonction compte_a_rebours avec le temps en paramètre moins 1.\n\n\nATTENTION Il faut utiliser la récursivité avec précaution car elle peut entraîner des fameuses erreurs de débordement de pile (Stack Overflow) qui ont donné leur nom au site.\n\n\n\nC’EST LA FIN\n\nC’est la fin de mon cours sur les Fondamentaux de Python. J’espère que vous avez pu apprendre quelque chose ou rafraîchir des connaissances ! Vous pouvez maintenant aller vous entraîner dans la rubrique Exercices de mon site ou en cliquant ici ! Pour toutes questions demandez à ChatGPT."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "C’est vraiment ghetto les cours de programmation avec elle là"
  },
  {
    "objectID": "comm_affiche.html",
    "href": "comm_affiche.html",
    "title": "Commentaires et Affichage",
    "section": "",
    "text": "Commentaires\n\nLes commentaires sont utilisés pour expliquer le code. Ils sont utiles pour vous mais surtout pour ceux qui vont lire votre code. Ils commencent par un # et prennent toute une ligne sauf s’ils suivent une instruction. A noter qu’ils ne sont pas comptabilisés quand on exécute du code Alors simplifiez la vie de votre prof et commentez votre code !\n\n\n# Voici un commentaire\n\nvariableTest = 2 # Voici un commentaire qui suit une ligne de code\n\n\n\nAffichage\n\nEn Python, pour afficher du texte, le contenu d’une variable ou même les deux, on utilise la fonction print().\n\n\nprint(\"Mes élèves sont les meilleurs\") # Affiche le texte entre les guillemets\nprint(variableTest) # Affiche la valeur de la variable\nprint(\"Mes élèves sont les meilleurs\", variableTest) # Affiche le texte entre les guillemets et la valeur de la variable\n\nMes élèves sont les meilleurs\n2\nMes élèves sont les meilleurs 2\n\n\n\n\nFormatage\n\nPour afficher du texte ainsi que des variables dans une même ligne il existe aussi une autre méthode que l’on appelle les f-strings. En utilisant les f-strings, vous pouvez insérer des variables directement dans une chaîne de caractères en plaçant leur nom entre des accolades {} à l’intérieur de la chaîne. Cela améliore grandement la lisibilité. Mais pour cela il faut placer un f DEVANT la chaîne de caractères. Voici un exemple :\n\n\nprenom = \"Johann\"\nage = \"22\"\nprint(f\"Je m'appelle {prenom} et j'ai {age} ans\")\n\nJe m'appelle Johann et j'ai 22 ans\n\n\n\nL’utilisation de la méthode .format() en Python permet aussi d’insérer des variables dans des chaînes de caractères en spécifiant des emplacements réservés (placeholders) avec des accolades {} , puis en utilisant la méthode .format() après la chaine de caractères pour remplacer ces emplacements par les valeurs des variables.\n\n\n# Utilisation de format()\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(prenom, age))\n\nBonjour, je m'appelle Johann et j'ai 22 ans.\n\n\n\n\nCalcul et arrondi\n\nDans votre vie de programmeur, vous effectuerez souvent des calculs. Mais leur résultat seront peut-être parfois trop précis, donc il faudra les arrondir ! Dans l’exemple suivant on va faire un calcul puis l’afficher une première fois sans l’arrondir puis un autre fois arrondi.\n\n\n# Calcul\nresultat = 10 / 3\n\n# Affichage\nprint(f\"Le résultat pas arrondi est {resultat}\")\n\n# Arrondi à deux chiffres après la virgule\n\nprint(f\"Le résultat arrondi est : {resultat:.2f}\")\n\nLe résultat pas arrondi est 3.3333333333333335\nLe résultat arrondi est : 3.33\n\n\n\nVous êtes maintenant un pro des commentaires et de l’affichage ! Cliquez-ici pour passer à la suite."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Les Fondamentaux de Python",
    "section": "",
    "text": "Bonjour ! Moi c’est Johann Cazenave, le remplaçant temporaire de votre prof de programmation Ményssa Chérifa-Luron, Ph.D car elle n’est pas encore rentrée de son voyage en Corée. Mais ce n’est pas pour autant que vous allez rater cette magnifique formation !\n\n\nAu programme ? Une révision des bases de Python car c’est souvent celles que l’on néglige le plus et qui sont finalement les bases de tout langage de programmation.\n\n\nMais Johann, c’est quoi Python ?\n\nPython, c’est un peu comme un  super-héros de la programmation, né en 1989 dans l’esprit créatif de Guido van Rossum, un fan de la comédie absurde des Monty Python. C’est un langage de programmation qui a tout pour plaire : il est polyvalent, gratuit comme l’air que vous respirez, et tellement simple à utiliser que même votre grand-mère pourrait s’y mettre (peut-être même votre chat, qui sait ?). Avec Python, vous pouvez jongler avec des milliers de lignes de code sans jamais vous prendre les pieds dans le tapis, car il est conçu pour être aussi convivial qu’un panda câlin. Vous pouvez l’installer sur tous vos gadgets électroniques, du PC de papa à votre smartphone dernier cri, sans débourser un sou. Et le meilleur dans tout ça ? Pas besoin de vous tracasser avec des compilateurs compliqués : Python est un langage interprété, ce qui signifie que vous pouvez voir les résultats de votre travail en un clin d’œil, sans avoir à attendre des heures que votre code se transforme en quelque chose de tangible. Alors, prêt à devenir un super-héros de la programmation avec Python ? Clique ici !"
  },
  {
    "objectID": "types_donnees.html",
    "href": "types_donnees.html",
    "title": "Types de données",
    "section": "",
    "text": "Types de Données (Structures séquentielles)\n\nChaque type de données séquentielles offre des caractéristiques distinctes et des utilisations spécifiques, permettant une grande souplesse dans le traitement des données. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilité et leurs capacités de stockage dynamique, les rendant particulièrement populaires dans de nombreux scénarios d’utilisation.\n\n\nLes Chaines de Caractères\n\nLes chaînes de caractères (str) sont utilisées pour stocker et manipuler du texte. Elles peuvent être définies en encadrant le texte entre des guillemets simples (‘…’), doubles (“…”), ou triples (’’‘…’’’ ou “““…”““) pour les chaînes multilignes.  Les chaînes sont des séquences de caractères indexées à partir de 0 et peuvent contenir des caractères spéciaux, comme des guillemets, grâce aux caractères d’échappement (). Les chaînes de caractères offrent une gamme complète de méthodes pour le traitement de texte, les rendant extrêmement polyvalentes et indispensables pour une variété d’applications, de manipulations de base à des opérations plus complexes. Voici quelques exemples :\n\n\n# Exemples de chaines de caractères\n# Chaine de caractères simple\nmaChaine = 'Python est un langage de programmation'\n\n# Chaine de caractères double\nmaChaine2 = \"Python est un langage de programmation\"\n\n# Chaine avec un caractère d'échappement\nmaChaine3 = 'Python c\\'est trop bien'\n\nprint(maChaine)\nprint(maChaine2)\nprint(maChaine3)\n\n# On peut accéder à des éléments\n# Premier caractère\npremierCaractere = maChaine[0] # 'P'\n# Dernier caractère\ndernierCaractere = maChaine[-1] # 'n'\n\nPython est un langage de programmation\nPython est un langage de programmation\nPython c'est trop bien\n\n\n\nLes méthodes sont des fonctions associées à des objets spécifiques, leur permettant d’exécuter des actions sur ces objets ou de manipuler leurs données internes. Contrairement aux fonctions indépendantes, les méthodes sont liées à des objets particuliers.  Par exemple, les méthodes des chaînes de caractères (str) sont conçues pour opérer sur des chaînes de caractères spécifiques. Elles sont appelées en utilisant la notation pointée, comme objet.methode(). Les méthodes de chaînes de caractères incluent des fonctionnalités telles que upper(), lower(), et replace(), permettant de convertir en majuscules, en minuscules ou de remplacer des parties spécifiques de la chaîne. Pour appeler une méthode, utilisez généralement la syntaxe objet.methode(arguments).  Pour utiliser ces méthodes vous pouvez les utiliser sur des variables contenant une chaine de caractères ou sur des chaines de caractères directement.\n\n\n# Méthodes pour les chaînes de caractères\n\n# isupper() et islower()\n\nchaineMaj = \"PYTHON\"\nchaineMin = \"python\"\nestMajuscule = chaineMaj.isupper()\nestMinuscule = chaineMin.islower()\nprint(estMajuscule) # Résultat : True\nprint(estMinuscule) # Résultat : True\n\n# upper() et lower()\nchaine = \"python est génial\"\nminToMaj = chaine.upper()\nprint(minToMaj) # Résultat : \"PYTHON EST GÉNIAL\"\n\nmajToMin = \"PYTHON est GÉNIAL\".lower()\nprint(majToMin) # Résultat : \"python est génial\"\n\nchaineCapitalize = chaine.capitalize() # La première lettre est en majuscule\nprint(chaineCapitalize) # Résultat : \"Python est génial\"\n\nchaineTitle = chaine.title() # La première lettre de chaque mot est en majuscule\nprint(chaineTitle) # Résultat : \"Python Est Génial\"\n\nposition = chaine.find(\"est\") # La méthode find() renvoie l'index de la première occurrence de la chaîne recherchée\nprint(position) # Résultat : 7\n\nchaineReplace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\") # La méthode replace() remplace une chaîne par une autre\nprint(chaineReplace) # Résultat : \"Les bananes sont rouges.\"\n\nchaineSplit = chaine.split(\" \") # La méthode split() découpe une chaîne en une liste de sous-chaînes\nprint(chaineSplit) # Résultat : [\"python\", \"est\", \"genial\"]\n\nelements = [\"apple\", \"orange\", \"banana\"]\ntextJoin = \", \".join(elements) # La méthode join() concatène les éléments d'une liste\nprint(textJoin) # Résultat : \"apple, orange, banana\"\n\ntextStrip = \" Bonjour \".strip() # La méthode strip() supprime les espaces en début et fin de chaîne\nprint(textStrip) # Résultat : \"Bonjour\"\n\nchaineStartsWith = chaine.startswith(\"Python\")\nprint(chaineStartsWith) # Résultat : True\n\nchaineEndsWith = chaine.endswith(\"génial\")\nprint(chaineEndsWith) # Résultat : True\n\nTrue\nTrue\nPYTHON EST GÉNIAL\npython est génial\nPython est génial\nPython Est Génial\n7\nLes bananes sont rouges.\n['python', 'est', 'génial']\napple, orange, banana\nBonjour\nFalse\nTrue\n\n\n\n\nLes listes\n\nLes listes représentent des structures de données permettant de stocker une séquence d’éléments. Elles offrent une grande souplesse, car elles peuvent contenir des éléments de types variés et sont modifiables. En tant que collections ordonnées, les éléments sont organisés de manière séquentielle, séparés par des virgules et enveloppés entre crochets pour les chaines de caractères. Pour créer une liste, il suffit d’encadrer une série d’éléments avec des crochets, séparés par des virgules, par exemple : [“Bonjour”, “Au revoir”, 75]. L’accès aux éléments se fait en utilisant leur index, en commençant par 0. Étant donné que les listes sont mutables, il est possible de modifier leurs éléments après leur création.\n\n\n# Définition d'une liste\nmaListe = [1, 2, 3, \"a\", \"b\", \"c\"]\nprint(maListe)\n\n# Accès au premier et au dernier élément\npremierElement = maListe[0]\ndernierElement = maListe[-1]\nprint(premierElement, \"\\n\", dernierElement)\n\n# Modification du deuxième élément\nmaListe[1] = \"deux\" \nprint(maListe)\n\n# Concaténation et Répétition\ncombinee = maListe + [\"autre\", \"liste\"]\nprint(combinee)\n\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n[1, 2, 3, 'a', 'b', 'c']\n1 \n c\n[1, 'deux', 3, 'a', 'b', 'c']\n[1, 'deux', 3, 'a', 'b', 'c', 'autre', 'liste']\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\nLe Slicing\n\nEn plus de permettre l’accès aux éléments d’une liste un par un, Python propose une syntaxe concise appelée slicing pour accéder aux sous-listes.\n\n\n# Définition d'une liste\nmaListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers\n\n# Accès à une sous-liste en utilisant le slicing\nsousListe1 = maListe[1:3]  # Récupère les éléments de l'index 1 inclus jusqu'à l'index 3 non inclus\nsousListe2 = maListe[:3]   # Récupère les trois premiers éléments de la liste\nsousListe3 = maListe[2:]   # Récupère les éléments à partir de l'index 2 jusqu'à la fin de la liste\nsousListe4 = maListe[::2]  # Récupère les éléments avec un pas de 2\n\n# Affichage des sous-listes\nprint(\"Sous-liste 1:\", sousListe1)  # Résultat : [1, 2]\nprint(\"Sous-liste 2:\", sousListe2)  # Résultat : [0, 1, 2]\nprint(\"Sous-liste 3:\", sousListe3)  # Résultat : [2, 3, 4]\nprint(\"Sous-liste 4:\", sousListe4)  # Résultat : [0, 2, 4]\n\n# Exemples de mutations de listes :\n\n# Cas 1: source de même longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]  # Remplace la sous-liste à partir de l'index 1 par [4, 5]\nprint(nums1)  # Résultat : [1, 4, 5]\n\n# Cas 2: source de longueur différente\nnums2 = nums1\nnums2[1:] = [6]  # Remplace la sous-liste à partir de l'index 1 par [6]\nprint(nums2)  # Résultat : [1, 6]\n\n# Vérification si les deux listes pointent vers le même objet en mémoire\nisSameObject = id(nums1) == id(nums2)  # Vérifie si les listes pointent vers le même objet\nprint(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifiées en place\n\nSous-liste 1: [1, 2]\nSous-liste 2: [0, 1, 2]\nSous-liste 3: [2, 3, 4]\nSous-liste 4: [0, 2, 4]\n[1, 4, 5]\n[1, 6]\nTrue\n\n\n\n\nLes méthodes de listes\n\nChaque méthode offre une fonctionnalité unique pour manipuler des listes, rendant ces structures de données extrêmement flexibles et puissantes pour une variété de tâches en programmation Python.\n\n\n\n\n\n\n\n\n\nMéthode\nDescription\nExemple d’Utilisation\n\n\n\n\nappend()\nAjoute un élément à la fin de la liste.\nliste.append(5)\n\n\nextend()\nÉtend la liste en ajoutant tous les éléments d’une autre liste.\nliste.extend([6, 7])\n\n\ninsert()\nInsère un élément à une position donnée.\nliste.insert(1, ‘a’)\n\n\nremove()\nSupprime la première occurrence d’un élément.\nliste.remove(‘a’)\n\n\npop()\nSupprime et renvoie un élément à une position donnée (par défaut, le dernier).\nliste.pop()\n\n\nclear()\nSupprime tous les éléments de la liste.\nliste.clear()\n\n\nindex()\nRetourne l’indice du premier élément correspondant.\nliste.index(‘a’)\n\n\ncount()\nCompte le nombre d’occurrences d’un élément spécifique.\nliste.count(5)\n\n\nsort()\nTrie les éléments de la liste (dans un ordre spécifique).\nliste.sort()\n\n\nreverse()\nInverse l’ordre des éléments de la liste.\nliste.reverse()\n\n\n\n\n# Création d'une liste de base\nmaListe = [1, 2, 3]\nprint(maListe)\n\n# Ajout d'un élément à la fin de la liste avec append()\nmaListe.append(\"quatre\")\nprint(\"Après append(quatre):\", maListe)\n\n# Extension de la liste en ajoutant les éléments d'une autre liste avec extend()\nmaListe.extend([5, 6])\nprint(\"Après extend([5, 6]):\", maListe)\n\n# Insertion d'un élément à un index spécifique avec insert()\nmaListe.insert(1, 'elephant')\nprint(\"Après insert(1, 'elephant'):\", maListe)\n\n# Suppression de la première occurrence d'un élément spécifié avec remove()\nmaListe.remove('elephant')\nprint(\"Après remove('elephant'):\", maListe)\n\n# Suppression et retour de l'élément à la fin de la liste avec pop()\nelementSupprime = maListe.pop()\nprint(\"Après pop():\", maListe, \", Élément supprimé:\", elementSupprime)\n\n# Suppression de tous les éléments de la liste avec clear()\nmaListe.clear()\nprint(\"Après clear():\", maListe)\n\n# Recréation de la liste pour les autres méthodes\nmaListe = [3, 1, 4, 2, 2]\n\n# Recherche de l'index de la première occurrence d'un élément spécifié avec index()\nindexDe4 = maListe.index(4)\nprint(\"Index de 4:\", indexDe4)\n\n# Comptage du nombre d'occurrences d'un élément spécifié avec count()\ncompteDe2 = maListe.count(2)\nprint(\"Nombre d'occurrences de 2:\", compteDe2)\n\n# Tri des éléments de la liste dans l'ordre croissant avec sort()\nmaListe.sort()\nprint(\"Après sort():\", maListe)\n\n# Inversion de l'ordre des éléments dans la liste avec reverse()\nmaListe.reverse()\nprint(\"Après reverse():\", maListe)\n\n[1, 2, 3]\nAprès append(quatre): [1, 2, 3, 'quatre']\nAprès extend([5, 6]): [1, 2, 3, 'quatre', 5, 6]\nAprès insert(1, 'elephant'): [1, 'elephant', 2, 3, 'quatre', 5, 6]\nAprès remove('elephant'): [1, 2, 3, 'quatre', 5, 6]\nAprès pop(): [1, 2, 3, 'quatre', 5] , Élément supprimé: 6\nAprès clear(): []\nIndex de 4: 2\nNombre d'occurrences de 2: 2\nAprès sort(): [1, 2, 2, 3, 4]\nAprès reverse(): [4, 3, 2, 2, 1]\n\n\n\n\nParcours de liste\n\nLe parcours de liste consiste à accéder séquentiellement à chaque élément d’une liste. Cela peut être fait de différentes manières, mais les plus courantes sont les boucles for et while .\n\n\nBoucle for : : La boucle for est la méthode la plus couramment utilisée pour parcourir une liste. Elle permet de traiter chaque élément individuellement.\nList Comprehension : La compréhension de liste est une méthode concise pour créer des listes. Elle permet de transformer une liste en une autre liste, en filtrant les éléments pour former une liste des résultats d’une expression donnée\n\n\nLa syntaxe de base d’une compréhension de liste est : [nouvelle_expression for item in iterable if condition**]\n\n\n\nnouvelle_expression est l’expression qui définit comment mapper les éléments de l’ iterable (par exemple, une liste).\n\n\n\n\nitem est la variable qui prend la valeur de chaque élément de l’ iterable pendant chaque itération.\n\n\n\n\ncondition est une condition optionnelle pour filtrer les éléments de l’ iterable.\n\n\n\n\nNous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une list comprehension :\n\n\n# récupérer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nautreListe = []\nautreListe2 = []\n\n# Avec une boucle for\nfor f in fruits:\n    if \"a\" in f:\n        autreListe.append(f)\nprint(autreListe)\n\n# Avec une list comprehension\nautreListe2 = [f for f in fruits if \"a\" in f ]\nprint(autreListe2)\n\n['apple', 'banana', 'mango']\n['apple', 'banana', 'mango']\n\n\n\nNous pouvons voir que les list comprehension sont un moyen d’écrire un code plus concis mais toujours autant compréhensible ! Alors pourquoi se prendre la tête avec une boucle for ? 😎  Elles peuvent aussi être utilisées pour effectuer des calculs sur tous les éléments d’une liste. Voyons ça :\n\n\n# Elevation des nombres d'une liste au carré\nnombres = [2, 5, 10, 111]\nnombreCarres = [x**2 for x in nombres]\nprint(nombreCarres) # [4, 25, 100, 12321]\n\n# Filtrer les nombres pairs d'une liste\ncarresPairs = [x for x in nombreCarres if x%2==0]\nprint(carresPairs)\n\n# Appliquer une méthode à tous les éléments\nfruits_majuscule = [fruit.upper() for fruit in fruits]\nprint(fruits_majuscule)\n\n[4, 25, 100, 12321]\n[4, 100]\n['APPLE', 'BANANA', 'CHERRY', 'KIWI', 'MANGO']\n\n\n\n\n\nLes tuples\n\nLes tuples sont des listes non mutables. Cela signifie que les éléments d’un tuple ne peuvent pas être modifiés après création. Les éléments sont séparés par dé virgules et sont entourés de parenthèses.\n\n\n\n\n\n\n\n\nAvantage\nDescription\n\n\n\n\nSécurité des Données\nParfait pour protéger les données contre les modifications.\n\n\nPerformance\nPlus rapides à parcourir que les listes.\n\n\nUtilisation en tant que Clés de Dictionnaire\nPeuvent être utilisés comme clés dans les dictionnaires, contrairement aux listes.\n\n\nRetour de Plusieurs Valeurs de Fonction\nUtilisés pour retourner plusieurs valeurs depuis une fonction.\n\n\nStockage de Données Constantes\nIdéaux pour stocker des données qui ne doivent pas être modifiées.\n\n\n\n\n# Définition d'un tuple\nmonTuple = (10, \"b\", 3.14)\nprint(monTuple)\n\nunAutreTuple = 20, \"c\", 4.28\nprint(unAutreTuple)\n\nelementIndex1 = monTuple[1]\nprint(elementIndex1)\n\n# Tuple à Un Élément\ntupleSingleton = 50,\nprint(tupleSingleton)\n\n# Tuple à Un Élément\ntupleSingleton = (50,)\n\n# Imbrication\ntupleImbrique = (10, (20, 30), (40, 50))\n\n# Méthodes Utiles\nlongueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3\nprint(longueur)\n\ncompteur = monTuple.count(\"b\")  # Compte le nombre de fois que \"b\" apparaît dans monTuple, ici 1\nprint(compteur)\n\nindice = monTuple.index(\"b\")  # Trouve l'indice de \"b\" dans monTuple, ici 1\nprint(indice)\n\n# L'affectation n'est pas possible\n# monTuple[1] = \"c\"\n\n(10, 'b', 3.14)\n(20, 'c', 4.28)\nb\n(50,)\n3\n1\n1\n\n\n\n\nLes ensembles\n\nLes ensembles sont :\n\n\nDes collections non ordonnées de valeurs uniques\nMutables, mais chaque élément doit être unique.\nNon-Ordonnés : Les ensembles ne maintiennent pas l’ordre des éléments. On ne peut donc pas accéder aux éléments par un index.\nLes éléments sont séparés par des virgules, et encadrés par des accolades\n\n\nOpérations sur les ensembles\n\n\n\n\n\n\n\n\nOpération\nSyntaxe\nDescription\n\n\n\n\nUnion\na | b\nRetourne un nouvel ensemble contenant tous les éléments uniques des ensembles a et b.\n\n\nIntersection\na & b\nRetourne un nouvel ensemble contenant uniquement les éléments communs aux ensembles a et b.\n\n\nDifférence\na - b\nRetourne un nouvel ensemble contenant les éléments de a qui ne sont pas dans b.\n\n\nDifférence Symétrique\na ^ b\nRetourne un nouvel ensemble contenant tous les éléments qui sont dans a ou b, mais pas dans les deux.\n\n\nAjout\na.add(x)\nAjoute l’élément x à l’ensemble a.\n\n\nSuppression\na.remove(x)\nSupprime l’élément x de l’ensemble a ; lève une erreur si x n’est pas présent.\n\n\nSuppression (sans erreur)\na.discard(x)\nSupprime l’élément x de l’ensemble a si x est présent ; ne fait rien sinon.\n\n\n\n\n\n\nLes dictionnaires\n\nLes dictionnaires sont un peu comme un format de JSON :\n\n\nIls sont basés sur des paires clés-valeurs\nOn accède aux valeurs via les clés\nIls sont mutables, on peut y ajouter des éléments, en supprimer ou en modifier\n\nUtilisation :\nStockage d’Informations Structurées : Parfait pour stocker des informations complexes comme des données utilisateur.\nRecherche Rapide : Utilisez des dictionnaires pour des recherches rapides basées sur des clés uniques\n\n\nIl existe des méthodes liées aux variables de type dictionnaire pour les manier :\n\n\n\n\n\n\n\n\nMéthode\nDescription\n\n\n\n\ndict.keys()\nRetourne une vue sur les clés du dictionnaire.\n\n\ndict.values()\nRetourne une vue sur les valeurs du dictionnaire.\n\n\ndict.items()\nRetourne une vue sur les paires (clé, valeur) du dictionnaire.\n\n\ndict.get(key)\nRetourne la valeur associée à la clé spécifiée.\n\n\n\nSi la clé n’existe pas, retourne None ou une valeur par défaut spécifiée en argument.\n\n\ndict.pop(key)\nRetourne la valeur associée à la clé spécifiée et supprime cette paire du dictionnaire.\n\n\n\nSi la clé n’existe pas, retourne une valeur par défaut spécifiée en argument ou lève une erreur.\n\n\ndict.popitem()\nRetourne et supprime une paire (clé, valeur) arbitraire du dictionnaire.\n\n\ndict.update(other_dict)\nMet à jour le dictionnaire avec les paires clé-valeur du dictionnaire spécifié en argument.\n\n\ndict.clear()\nSupprime toutes les paires clé-valeur du dictionnaire, le laissant vide.\n\n\n\n\n# Création d'un dictionnaire\nindividu = {\"nom\": \"Alice\", \"age\": 30}\nautre_dictionnaire = dict(nom=\"Bob\", age=25)\nindividu\n\n# Ajout et mise à jour\nindividu[\"profession\"] = \"Développeur\"\nindividu\n\n# Mise à jour de plusieurs clés\nindividu.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\nindividu\n\n# Utilisation de keys()\ncles = individu.keys()\nprint(\"Clés:\", cles)\n\n# Utilisation de values()\nvaleurs = individu.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = individu.items()\nprint(\"Paires clé-valeur:\", paires)\n\n# Utilisation de get()\nnom_personne = individu.get(\"nom\")\nage_personne = individu.get(\"age\")\nprint(nom_personne, age_personne)\n\n# Récupération de la valeur de la clé \"ville\"\nville = individu.get(\"ville\")\nville\n\n# Récupération de la valeur de la clé \"ville\" avec une valeur par défaut\nville = individu.get(\"ville\", \"Non spécifiée\")\nprint(\"Ville:\", ville)\n\n# Parcours des clés\nprint(\"\\nParcours des clés:\")\nfor cle in individu.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in individu.values():\n    print(valeur)\n\n# Parcours des paires clé-valeur\nprint(\"\\nParcours des paires clé-valeur:\")\nfor cle, valeur in individu.items():\n    print(cle, \":\", valeur)\n\n# Parcours des paires clé-valeur avec enumerate\nprint(\"\\nParcours des paires clé-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(individu.items()):\n    print(f\"Index {index}: Clé = {cle}, Valeur = {valeur}\")\n\n# Suppression d'une clé et de sa valeur\ndel individu[\"age\"]\nprint(individu)\n\n# Suppression d'une clé avec retour de sa valeur\nprofession = individu.pop(\"profession\")\nprint(profession)\n\n# Suppression d'une clé avec retour de sa valeur et gestion de l'absence de la clé\nville_supprimee = individu.pop(\"ville\", \"Non spécifiée\")\nprint(ville_supprimee)\n\n# Affichage du dictionnaire après les suppressions\nprint(individu)\n\nClés: dict_keys(['nom', 'age', 'profession'])\nValeurs: dict_values(['Romain', 30, 'Data Scientist'])\nPaires clé-valeur: dict_items([('nom', 'Romain'), ('age', 30), ('profession', 'Data Scientist')])\nRomain 30\nVille: Non spécifiée\n\nParcours des clés:\nnom\nage\nprofession\n\nParcours des valeurs:\nRomain\n30\nData Scientist\n\nParcours des paires clé-valeur:\nnom : Romain\nage : 30\nprofession : Data Scientist\n\nParcours des paires clé-valeur avec enumerate:\nIndex 0: Clé = nom, Valeur = Romain\nIndex 1: Clé = age, Valeur = 30\nIndex 2: Clé = profession, Valeur = Data Scientist\n{'nom': 'Romain', 'profession': 'Data Scientist'}\nData Scientist\nNon spécifiée\n{'nom': 'Romain'}\n\n\n\nVous êtes maintenant des pros des données séquentielles ! Pensez-vous que cela suffit ? Continuez de vous instruire en cliquant ici pour passer à la suite."
  },
  {
    "objectID": "exercices.html",
    "href": "exercices.html",
    "title": "A vous de jouer !",
    "section": "",
    "text": "A vous de jouer !\n\nVous avez révisé vos bases en Python ? Allons tester tout ca !\n\n\nJe vous ai préparé des exercices sur chaque partie de mon cours pour que vous pussiez mettre en pratique les notions que l’on a vues ensemble 💪 Choisissez le chapitre que vous souhaitez réviser ci-dessous :\n\n\n\nVariables et Opérations"
  }
]