{"title":"Types de donn√©es","markdown":{"yaml":{"title":"Types de donn√©es"},"headingText":"Types de Donn√©es (Structures s√©quentielles)","containsRefs":false,"markdown":"\n\n\n<p id=textIntro>Chaque type de donn√©es s√©quentielles offre des caract√©ristiques distinctes et des utilisations sp√©cifiques, permettant une grande souplesse dans le traitement des donn√©es. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilit√© et leurs capacit√©s de stockage dynamique, les rendant particuli√®rement populaires dans de nombreux sc√©narios d'utilisation.</p>\n\n#### Les Chaines de Caract√®res\n\n<p id=textIntro>\nLes **cha√Ænes de caract√®res (str)** sont utilis√©es pour stocker et manipuler du texte. Elles peuvent √™tre d√©finies en encadrant le texte entre des guillemets **simples** ('...'), **doubles** (\"...\"), ou **triples** ('''...''' ou \"\"\"...\"\"\") pour les cha√Ænes multilignes. <br>\nLes cha√Ænes sont des s√©quences de caract√®res **index√©es √† partir de 0** et peuvent contenir des caract√®res sp√©ciaux, comme des guillemets, gr√¢ce aux caract√®res d'√©chappement (\\). Les cha√Ænes de caract√®res offrent une gamme compl√®te de m√©thodes pour le traitement de texte, les rendant extr√™mement polyvalentes et **indispensables** pour une vari√©t√© d'applications, de manipulations de base √† des op√©rations plus complexes. Voici quelques exemples :\n</p>\n\n```{python}\n# Exemples de chaines de caract√®res\n# Chaine de caract√®res simple\nmaChaine = 'Python est un langage de programmation'\n\n# Chaine de caract√®res double\nmaChaine2 = \"Python est un langage de programmation\"\n\n# Chaine avec un caract√®re d'√©chappement\nmaChaine3 = 'Python c\\'est trop bien'\n\nprint(maChaine)\nprint(maChaine2)\nprint(maChaine3)\n\n# On peut acc√©der √† des √©l√©ments\n# Premier caract√®re\npremierCaractere = maChaine[0] # 'P'\n# Dernier caract√®re\ndernierCaractere = maChaine[-1] # 'n'\n\n```\n<p id=textIntro> \nLes m√©thodes sont des fonctions associ√©es √† des objets sp√©cifiques, leur permettant d'ex√©cuter des actions sur ces objets ou de manipuler leurs donn√©es internes. Contrairement aux fonctions ind√©pendantes, les m√©thodes sont li√©es √† des objets particuliers.\n<br> Par exemple, les m√©thodes des **cha√Ænes de caract√®res (str)** sont con√ßues pour **op√©rer sur des cha√Ænes de caract√®res sp√©cifiques**. Elles sont appel√©es en utilisant la notation point√©e, comme **objet.methode()**. Les m√©thodes de cha√Ænes de caract√®res incluent des fonctionnalit√©s telles que **upper()**, **lower()**, et **replace()**, permettant de convertir en majuscules, en minuscules ou de remplacer des parties sp√©cifiques de la cha√Æne. Pour appeler une m√©thode, utilisez g√©n√©ralement la syntaxe objet.methode(arguments).\n<br>\nPour utiliser ces m√©thodes vous pouvez les utiliser sur des variables contenant une chaine de caract√®res ou sur des chaines de caract√®res directement.\n</p>\n\n```{python}\n# M√©thodes pour les cha√Ænes de caract√®res\n\n# isupper() et islower()\n\nchaineMaj = \"PYTHON\"\nchaineMin = \"python\"\nestMajuscule = chaineMaj.isupper()\nestMinuscule = chaineMin.islower()\nprint(estMajuscule) # R√©sultat : True\nprint(estMinuscule) # R√©sultat : True\n\n# upper() et lower()\nchaine = \"python est g√©nial\"\nminToMaj = chaine.upper()\nprint(minToMaj) # R√©sultat : \"PYTHON EST G√âNIAL\"\n\nmajToMin = \"PYTHON est G√âNIAL\".lower()\nprint(majToMin) # R√©sultat : \"python est g√©nial\"\n\nchaineCapitalize = chaine.capitalize() # La premi√®re lettre est en majuscule\nprint(chaineCapitalize) # R√©sultat : \"Python est g√©nial\"\n\nchaineTitle = chaine.title() # La premi√®re lettre de chaque mot est en majuscule\nprint(chaineTitle) # R√©sultat : \"Python Est G√©nial\"\n\nposition = chaine.find(\"est\") # La m√©thode find() renvoie l'index de la premi√®re occurrence de la cha√Æne recherch√©e\nprint(position) # R√©sultat : 7\n\nchaineReplace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\") # La m√©thode replace() remplace une cha√Æne par une autre\nprint(chaineReplace) # R√©sultat : \"Les bananes sont rouges.\"\n\nchaineSplit = chaine.split(\" \") # La m√©thode split() d√©coupe une cha√Æne en une liste de sous-cha√Ænes\nprint(chaineSplit) # R√©sultat : [\"python\", \"est\", \"genial\"]\n\nelements = [\"apple\", \"orange\", \"banana\"]\ntextJoin = \", \".join(elements) # La m√©thode join() concat√®ne les √©l√©ments d'une liste\nprint(textJoin) # R√©sultat : \"apple, orange, banana\"\n\ntextStrip = \" Bonjour \".strip() # La m√©thode strip() supprime les espaces en d√©but et fin de cha√Æne\nprint(textStrip) # R√©sultat : \"Bonjour\"\n\nchaineStartsWith = chaine.startswith(\"Python\")\nprint(chaineStartsWith) # R√©sultat : True\n\nchaineEndsWith = chaine.endswith(\"g√©nial\")\nprint(chaineEndsWith) # R√©sultat : True\n\n```\n\n#### Les listes\n<p id=textIntro>\nLes listes repr√©sentent des **structures de donn√©es** permettant de stocker une **s√©quence d'√©l√©ments**. Elles offrent une grande souplesse, car elles peuvent contenir des √©l√©ments de types vari√©s et sont modifiables. En tant que collections ordonn√©es, les √©l√©ments sont organis√©s de mani√®re **s√©quentielle**, s√©par√©s par des virgules et envelopp√©s entre crochets pour les chaines de caract√®res. Pour cr√©er une liste, il suffit d'encadrer une s√©rie d'√©l√©ments avec des crochets, s√©par√©s par des virgules, par exemple : [\"Bonjour\", \"Au revoir\", 75]. L'acc√®s aux √©l√©ments se fait en utilisant leur index, en commen√ßant par 0. √âtant donn√© que les listes sont **mutables**, il est possible de modifier leurs √©l√©ments **apr√®s leur cr√©ation**.\n</p>\n\n```{python}\n\n# D√©finition d'une liste\nmaListe = [1, 2, 3, \"a\", \"b\", \"c\"]\nprint(maListe)\n\n# Acc√®s au premier et au dernier √©l√©ment\npremierElement = maListe[0]\ndernierElement = maListe[-1]\nprint(premierElement, \"\\n\", dernierElement)\n\n# Modification du deuxi√®me √©l√©ment\nmaListe[1] = \"deux\" \nprint(maListe)\n\n# Concat√©nation et R√©p√©tition\ncombinee = maListe + [\"autre\", \"liste\"]\nprint(combinee)\n\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n\n```\n\n##### Le Slicing\n<p id=textIntro>En plus de permettre l'acc√®s aux √©l√©ments d'une liste un par un, Python propose une syntaxe concise appel√©e **slicing** pour acc√©der aux sous-listes.</p>\n\n```{python}\n\n# D√©finition d'une liste\nmaListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers\n\n# Acc√®s √† une sous-liste en utilisant le slicing\nsousListe1 = maListe[1:3]  # R√©cup√®re les √©l√©ments de l'index 1 inclus jusqu'√† l'index 3 non inclus\nsousListe2 = maListe[:3]   # R√©cup√®re les trois premiers √©l√©ments de la liste\nsousListe3 = maListe[2:]   # R√©cup√®re les √©l√©ments √† partir de l'index 2 jusqu'√† la fin de la liste\nsousListe4 = maListe[::2]  # R√©cup√®re les √©l√©ments avec un pas de 2\n\n# Affichage des sous-listes\nprint(\"Sous-liste 1:\", sousListe1)  # R√©sultat : [1, 2]\nprint(\"Sous-liste 2:\", sousListe2)  # R√©sultat : [0, 1, 2]\nprint(\"Sous-liste 3:\", sousListe3)  # R√©sultat : [2, 3, 4]\nprint(\"Sous-liste 4:\", sousListe4)  # R√©sultat : [0, 2, 4]\n\n# Exemples de mutations de listes :\n\n# Cas 1: source de m√™me longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]  # Remplace la sous-liste √† partir de l'index 1 par [4, 5]\nprint(nums1)  # R√©sultat : [1, 4, 5]\n\n# Cas 2: source de longueur diff√©rente\nnums2 = nums1\nnums2[1:] = [6]  # Remplace la sous-liste √† partir de l'index 1 par [6]\nprint(nums2)  # R√©sultat : [1, 6]\n\n# V√©rification si les deux listes pointent vers le m√™me objet en m√©moire\nisSameObject = id(nums1) == id(nums2)  # V√©rifie si les listes pointent vers le m√™me objet\nprint(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifi√©es en place\n```\n\n##### Les m√©thodes de listes\n<p id=textIntro>Chaque m√©thode offre une fonctionnalit√© unique pour manipuler des listes, rendant ces structures de donn√©es\nextr√™mement flexibles et puissantes pour une vari√©t√© de t√¢ches en programmation Python.</p>\n\n| **M√©thode** | **Description** | **Exemple d'Utilisation** |\n| --- | --- | --- |\n| **append()** | Ajoute **un √©l√©ment** √† la fin de la liste. | liste.append(5) |\n| **extend()** | √âtend la liste en ajoutant **tous les √©l√©ments d'une autre liste**. | liste.extend([6, 7]) |\n| **insert()** | Ins√®re un √©l√©ment √† une position donn√©e. | liste.insert(1, 'a') |\n| **remove()** | Supprime la premi√®re occurrence d'un √©l√©ment. | liste.remove('a') |\n| **pop()** | Supprime et renvoie un √©l√©ment √† une position donn√©e (par d√©faut, le dernier). | liste.pop() |\n| **clear()** | Supprime tous les √©l√©ments de la liste. | liste.clear() |\n| **index()** | Retourne l'indice du premier √©l√©ment correspondant. | liste.index('a') |\n| **count()** | Compte le nombre d'occurrences d'un √©l√©ment sp√©cifique. | liste.count(5) |\n| **sort()** | Trie les √©l√©ments de la liste (dans un ordre sp√©cifique). | liste.sort() |\n| **reverse()** | Inverse l'ordre des √©l√©ments de la liste. | liste.reverse() |\n\n```{python}\n# Cr√©ation d'une liste de base\nmaListe = [1, 2, 3]\nprint(maListe)\n\n# Ajout d'un √©l√©ment √† la fin de la liste avec append()\nmaListe.append(\"quatre\")\nprint(\"Apr√®s append(quatre):\", maListe)\n\n# Extension de la liste en ajoutant les √©l√©ments d'une autre liste avec extend()\nmaListe.extend([5, 6])\nprint(\"Apr√®s extend([5, 6]):\", maListe)\n\n# Insertion d'un √©l√©ment √† un index sp√©cifique avec insert()\nmaListe.insert(1, 'elephant')\nprint(\"Apr√®s insert(1, 'elephant'):\", maListe)\n\n# Suppression de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec remove()\nmaListe.remove('elephant')\nprint(\"Apr√®s remove('elephant'):\", maListe)\n\n# Suppression et retour de l'√©l√©ment √† la fin de la liste avec pop()\nelementSupprime = maListe.pop()\nprint(\"Apr√®s pop():\", maListe, \", √âl√©ment supprim√©:\", elementSupprime)\n\n# Suppression de tous les √©l√©ments de la liste avec clear()\nmaListe.clear()\nprint(\"Apr√®s clear():\", maListe)\n\n# Recr√©ation de la liste pour les autres m√©thodes\nmaListe = [3, 1, 4, 2, 2]\n\n# Recherche de l'index de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec index()\nindexDe4 = maListe.index(4)\nprint(\"Index de 4:\", indexDe4)\n\n# Comptage du nombre d'occurrences d'un √©l√©ment sp√©cifi√© avec count()\ncompteDe2 = maListe.count(2)\nprint(\"Nombre d'occurrences de 2:\", compteDe2)\n\n# Tri des √©l√©ments de la liste dans l'ordre croissant avec sort()\nmaListe.sort()\nprint(\"Apr√®s sort():\", maListe)\n\n# Inversion de l'ordre des √©l√©ments dans la liste avec reverse()\nmaListe.reverse()\nprint(\"Apr√®s reverse():\", maListe)\n\n```\n\n##### Parcours de liste\n<p id=textIntro> Le parcours de liste consiste √† acc√©der s√©quentiellement √† chaque √©l√©ment d'une liste. Cela peut √™tre fait de diff√©rentes\nmani√®res, mais les plus courantes sont les boucles **for** et **while** .</p>\n\n* Boucle for : : La boucle for est la m√©thode la plus couramment utilis√©e pour parcourir une liste. Elle permet de traiter chaque √©l√©ment\nindividuellement.\n\n* List Comprehension : La compr√©hension de liste est une m√©thode concise pour cr√©er des listes. Elle permet de transformer une liste en\nune autre liste, en filtrant les √©l√©ments pour former une liste des r√©sultats d'une expression donn√©e\n\n<p id=textIntro> La syntaxe de base d'une compr√©hension de liste est :\n**[**``nouvelle_expression`` **for ``item`` **in** ``iterable`` **if** ``condition``**]**\n<ul>\n<li><p id=textIntro>**nouvelle_expression** est l'expression qui d√©finit comment **mapper** les √©l√©ments de l' iterable (par exemple, une liste).</p></li>\n<li><p id=textIntro>**item** est la variable qui prend la valeur de chaque √©l√©ment de l' iterable pendant chaque it√©ration.</p></li>\n<li><p id=textIntro> **condition** est une condition optionnelle pour filtrer les √©l√©ments de l' iterable. </p>\n</li>\n</ul>\n<p id=textIntro>Nous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une **list comprehension** :</p>\n\n```{python}\n\n# r√©cup√©rer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nautreListe = []\nautreListe2 = []\n\n# Avec une boucle for\nfor f in fruits:\n    if \"a\" in f:\n        autreListe.append(f)\nprint(autreListe)\n\n# Avec une list comprehension\nautreListe2 = [f for f in fruits if \"a\" in f ]\nprint(autreListe2)\n\n\n```\n\n<p id=textIntro>Nous pouvons voir que **les list comprehension** sont un moyen d'√©crire un code plus concis mais toujours autant compr√©hensible ! Alors pourquoi se prendre la t√™te avec une boucle for ? üòé\n<br>\nElles peuvent aussi √™tre utilis√©es pour effectuer des calculs sur tous les √©l√©ments d'une liste. Voyons √ßa :</p>\n\n```{python}\n# Elevation des nombres d'une liste au carr√©\nnombres = [2, 5, 10, 111]\nnombreCarres = [x**2 for x in nombres]\nprint(nombreCarres) # [4, 25, 100, 12321]\n\n# Filtrer les nombres pairs d'une liste\ncarresPairs = [x for x in nombreCarres if x%2==0]\nprint(carresPairs)\n\n# Appliquer une m√©thode √† tous les √©l√©ments\nfruits_majuscule = [fruit.upper() for fruit in fruits]\nprint(fruits_majuscule)\n\n```\n\n#### Les tuples\n\n<p id=textIntro>Les tuples sont des listes **non mutables**. Cela signifie que les √©l√©ments d'un tuple ne peuvent pas √™tre modifi√©s apr√®s cr√©ation. Les √©l√©ments sont s√©par√©s par d√© virgules et sont entour√©s de parenth√®ses.</p>\n\n| **Avantage**                      | **Description**                                               |\n|------------------------------|-----------------------------------------------------------|\n| **S√©curit√© des Donn√©es**         | Parfait pour prot√©ger les donn√©es contre les modifications. |\n| **Performance**                  | Plus rapides √† parcourir que les listes.                 |\n| **Utilisation en tant que Cl√©s de Dictionnaire** | Peuvent √™tre utilis√©s comme cl√©s dans les dictionnaires, contrairement aux listes. |\n| **Retour de Plusieurs Valeurs de Fonction** | Utilis√©s pour retourner plusieurs valeurs depuis une fonction. |\n| **Stockage de Donn√©es Constantes** | Id√©aux pour stocker des donn√©es qui ne doivent pas √™tre modifi√©es. |\n\n```{python}\n# D√©finition d'un tuple\nmonTuple = (10, \"b\", 3.14)\nprint(monTuple)\n\nunAutreTuple = 20, \"c\", 4.28\nprint(unAutreTuple)\n\nelementIndex1 = monTuple[1]\nprint(elementIndex1)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = 50,\nprint(tupleSingleton)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = (50,)\n\n# Imbrication\ntupleImbrique = (10, (20, 30), (40, 50))\n\n# M√©thodes Utiles\nlongueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3\nprint(longueur)\n\ncompteur = monTuple.count(\"b\")  # Compte le nombre de fois que \"b\" appara√Æt dans monTuple, ici 1\nprint(compteur)\n\nindice = monTuple.index(\"b\")  # Trouve l'indice de \"b\" dans monTuple, ici 1\nprint(indice)\n\n# L'affectation n'est pas possible\n# monTuple[1] = \"c\"\n\n```\n\n#### Les ensembles\n<p id=textIntro>Les ensembles sont :</p>\n\n* Des collections non ordonn√©es de **valeurs uniques**\n\n* **Mutables**, mais chaque √©l√©ment doit √™tre **unique**.\n\n* **Non-Ordonn√©s** : Les ensembles ne **maintiennent pas** l'ordre des √©l√©ments. On ne peut donc pas acc√©der aux √©l√©ments par un index.\n\n* Les √©l√©ments sont s√©par√©s par des virgules, et encadr√©s par des accolades\n\n##### Op√©rations sur les ensembles\n\n| **Op√©ration**         | **Syntaxe**    | Description                                                                              |\n|-----------------------|---------------|------------------------------------------------------------------------------------------|\n| **Union**             | **a \\| b**    | Retourne un nouvel ensemble contenant tous les √©l√©ments uniques des ensembles a et b.   |\n| **Intersection**      | **a & b**     | Retourne un nouvel ensemble contenant uniquement les √©l√©ments communs aux ensembles a et b. |\n| **Diff√©rence**        | **a - b**     | Retourne un nouvel ensemble contenant les √©l√©ments de a qui ne sont pas dans b.          |\n| **Diff√©rence Sym√©trique** | **a ^ b** | Retourne un nouvel ensemble contenant tous les √©l√©ments qui sont dans a ou b, mais pas dans les deux. |\n| **Ajout**             | **a.add(x)**  | Ajoute l'√©l√©ment x √† l'ensemble a.                                                     |\n| **Suppression**       | **a.remove(x)**| Supprime l'√©l√©ment x de l'ensemble a ; **l√®ve une erreur si x n'est pas pr√©sent**.           |\n| **Suppression (sans erreur)** | **a.discard(x)** | Supprime l'√©l√©ment x de l'ensemble a si x est pr√©sent ; **ne fait rien sinon**.           |\n\n#### Les dictionnaires\n\n<p id=textIntro>Les dictionnaires sont un peu comme un format de JSON :</p>\n\n* Ils sont bas√©s sur des paires **cl√©s-valeurs**\n* On acc√®de aux valeurs via les **cl√©s**\n* Ils sont **mutables**, on peut y **ajouter** des √©l√©ments, en **supprimer** ou en **modifier**\n*   \n* Utilisation :\n- **Stockage d'Informations Structur√©es** : Parfait pour stocker des informations complexes comme des donn√©es utilisateur.\n- **Recherche Rapide** : Utilisez des dictionnaires pour des recherches rapides bas√©es sur des cl√©s uniques\n\n<p id=textIntro>Il existe des m√©thodes li√©es aux variables de type dictionnaire pour les manier :</p>\n\n| M√©thode                | Description                                                                                   |\n|------------------------|-----------------------------------------------------------------------------------------------|\n| **`dict.keys()`**      | Retourne une vue sur les cl√©s du dictionnaire.                                               |\n| **`dict.values()`**    | Retourne une vue sur les valeurs du dictionnaire.                                            |\n| **`dict.items()`**     | Retourne une vue sur les paires (cl√©, valeur) du dictionnaire.                               |\n| **`dict.get(key)`**    | Retourne la valeur associ√©e √† la cl√© sp√©cifi√©e.                                               |\n|                        | Si la cl√© n'existe pas, retourne `None` ou une valeur par d√©faut sp√©cifi√©e en argument.       |\n| **`dict.pop(key)`**    | Retourne la valeur associ√©e √† la cl√© sp√©cifi√©e et supprime cette paire du dictionnaire.\n|                        | Si la cl√© n'existe pas, retourne une valeur par d√©faut sp√©cifi√©e en argument ou l√®ve une erreur.                                                                             |\n| **`dict.popitem()`**  | Retourne et supprime une paire (cl√©, valeur) arbitraire du dictionnaire.                     |\n| **`dict.update(other_dict)`** | Met √† jour le dictionnaire avec les paires cl√©-valeur du dictionnaire sp√©cifi√© en argument. |\n| **`dict.clear()`**     | Supprime toutes les paires cl√©-valeur du dictionnaire, le laissant vide.                      |\n\n```{python}\n# Cr√©ation d'un dictionnaire\nindividu = {\"nom\": \"Alice\", \"age\": 30}\nautre_dictionnaire = dict(nom=\"Bob\", age=25)\nindividu\n\n# Ajout et mise √† jour\nindividu[\"profession\"] = \"D√©veloppeur\"\nindividu\n\n# Mise √† jour de plusieurs cl√©s\nindividu.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\nindividu\n\n# Utilisation de keys()\ncles = individu.keys()\nprint(\"Cl√©s:\", cles)\n\n# Utilisation de values()\nvaleurs = individu.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = individu.items()\nprint(\"Paires cl√©-valeur:\", paires)\n\n# Utilisation de get()\nnom_personne = individu.get(\"nom\")\nage_personne = individu.get(\"age\")\nprint(nom_personne, age_personne)\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\"\nville = individu.get(\"ville\")\nville\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\" avec une valeur par d√©faut\nville = individu.get(\"ville\", \"Non sp√©cifi√©e\")\nprint(\"Ville:\", ville)\n\n# Parcours des cl√©s\nprint(\"\\nParcours des cl√©s:\")\nfor cle in individu.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in individu.values():\n    print(valeur)\n\n# Parcours des paires cl√©-valeur\nprint(\"\\nParcours des paires cl√©-valeur:\")\nfor cle, valeur in individu.items():\n    print(cle, \":\", valeur)\n\n# Parcours des paires cl√©-valeur avec enumerate\nprint(\"\\nParcours des paires cl√©-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(individu.items()):\n    print(f\"Index {index}: Cl√© = {cle}, Valeur = {valeur}\")\n\n# Suppression d'une cl√© et de sa valeur\ndel individu[\"age\"]\nprint(individu)\n\n# Suppression d'une cl√© avec retour de sa valeur\nprofession = individu.pop(\"profession\")\nprint(profession)\n\n# Suppression d'une cl√© avec retour de sa valeur et gestion de l'absence de la cl√©\nville_supprimee = individu.pop(\"ville\", \"Non sp√©cifi√©e\")\nprint(ville_supprimee)\n\n# Affichage du dictionnaire apr√®s les suppressions\nprint(individu)\n\n\n```\n\n<p id=textIntro>Vous √™tes maintenant des pros des donn√©es s√©quentielles ! Pensez-vous que cela suffit ? Continuez de vous instruire en <a href=comm_affiche.qmd>cliquant ici</a> pour passer √† la suite.</p>\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n### Types de Donn√©es (Structures s√©quentielles)\n\n<p id=textIntro>Chaque type de donn√©es s√©quentielles offre des caract√©ristiques distinctes et des utilisations sp√©cifiques, permettant une grande souplesse dans le traitement des donn√©es. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilit√© et leurs capacit√©s de stockage dynamique, les rendant particuli√®rement populaires dans de nombreux sc√©narios d'utilisation.</p>\n\n#### Les Chaines de Caract√®res\n\n<p id=textIntro>\nLes **cha√Ænes de caract√®res (str)** sont utilis√©es pour stocker et manipuler du texte. Elles peuvent √™tre d√©finies en encadrant le texte entre des guillemets **simples** ('...'), **doubles** (\"...\"), ou **triples** ('''...''' ou \"\"\"...\"\"\") pour les cha√Ænes multilignes. <br>\nLes cha√Ænes sont des s√©quences de caract√®res **index√©es √† partir de 0** et peuvent contenir des caract√®res sp√©ciaux, comme des guillemets, gr√¢ce aux caract√®res d'√©chappement (\\). Les cha√Ænes de caract√®res offrent une gamme compl√®te de m√©thodes pour le traitement de texte, les rendant extr√™mement polyvalentes et **indispensables** pour une vari√©t√© d'applications, de manipulations de base √† des op√©rations plus complexes. Voici quelques exemples :\n</p>\n\n```{python}\n# Exemples de chaines de caract√®res\n# Chaine de caract√®res simple\nmaChaine = 'Python est un langage de programmation'\n\n# Chaine de caract√®res double\nmaChaine2 = \"Python est un langage de programmation\"\n\n# Chaine avec un caract√®re d'√©chappement\nmaChaine3 = 'Python c\\'est trop bien'\n\nprint(maChaine)\nprint(maChaine2)\nprint(maChaine3)\n\n# On peut acc√©der √† des √©l√©ments\n# Premier caract√®re\npremierCaractere = maChaine[0] # 'P'\n# Dernier caract√®re\ndernierCaractere = maChaine[-1] # 'n'\n\n```\n<p id=textIntro> \nLes m√©thodes sont des fonctions associ√©es √† des objets sp√©cifiques, leur permettant d'ex√©cuter des actions sur ces objets ou de manipuler leurs donn√©es internes. Contrairement aux fonctions ind√©pendantes, les m√©thodes sont li√©es √† des objets particuliers.\n<br> Par exemple, les m√©thodes des **cha√Ænes de caract√®res (str)** sont con√ßues pour **op√©rer sur des cha√Ænes de caract√®res sp√©cifiques**. Elles sont appel√©es en utilisant la notation point√©e, comme **objet.methode()**. Les m√©thodes de cha√Ænes de caract√®res incluent des fonctionnalit√©s telles que **upper()**, **lower()**, et **replace()**, permettant de convertir en majuscules, en minuscules ou de remplacer des parties sp√©cifiques de la cha√Æne. Pour appeler une m√©thode, utilisez g√©n√©ralement la syntaxe objet.methode(arguments).\n<br>\nPour utiliser ces m√©thodes vous pouvez les utiliser sur des variables contenant une chaine de caract√®res ou sur des chaines de caract√®res directement.\n</p>\n\n```{python}\n# M√©thodes pour les cha√Ænes de caract√®res\n\n# isupper() et islower()\n\nchaineMaj = \"PYTHON\"\nchaineMin = \"python\"\nestMajuscule = chaineMaj.isupper()\nestMinuscule = chaineMin.islower()\nprint(estMajuscule) # R√©sultat : True\nprint(estMinuscule) # R√©sultat : True\n\n# upper() et lower()\nchaine = \"python est g√©nial\"\nminToMaj = chaine.upper()\nprint(minToMaj) # R√©sultat : \"PYTHON EST G√âNIAL\"\n\nmajToMin = \"PYTHON est G√âNIAL\".lower()\nprint(majToMin) # R√©sultat : \"python est g√©nial\"\n\nchaineCapitalize = chaine.capitalize() # La premi√®re lettre est en majuscule\nprint(chaineCapitalize) # R√©sultat : \"Python est g√©nial\"\n\nchaineTitle = chaine.title() # La premi√®re lettre de chaque mot est en majuscule\nprint(chaineTitle) # R√©sultat : \"Python Est G√©nial\"\n\nposition = chaine.find(\"est\") # La m√©thode find() renvoie l'index de la premi√®re occurrence de la cha√Æne recherch√©e\nprint(position) # R√©sultat : 7\n\nchaineReplace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\") # La m√©thode replace() remplace une cha√Æne par une autre\nprint(chaineReplace) # R√©sultat : \"Les bananes sont rouges.\"\n\nchaineSplit = chaine.split(\" \") # La m√©thode split() d√©coupe une cha√Æne en une liste de sous-cha√Ænes\nprint(chaineSplit) # R√©sultat : [\"python\", \"est\", \"genial\"]\n\nelements = [\"apple\", \"orange\", \"banana\"]\ntextJoin = \", \".join(elements) # La m√©thode join() concat√®ne les √©l√©ments d'une liste\nprint(textJoin) # R√©sultat : \"apple, orange, banana\"\n\ntextStrip = \" Bonjour \".strip() # La m√©thode strip() supprime les espaces en d√©but et fin de cha√Æne\nprint(textStrip) # R√©sultat : \"Bonjour\"\n\nchaineStartsWith = chaine.startswith(\"Python\")\nprint(chaineStartsWith) # R√©sultat : True\n\nchaineEndsWith = chaine.endswith(\"g√©nial\")\nprint(chaineEndsWith) # R√©sultat : True\n\n```\n\n#### Les listes\n<p id=textIntro>\nLes listes repr√©sentent des **structures de donn√©es** permettant de stocker une **s√©quence d'√©l√©ments**. Elles offrent une grande souplesse, car elles peuvent contenir des √©l√©ments de types vari√©s et sont modifiables. En tant que collections ordonn√©es, les √©l√©ments sont organis√©s de mani√®re **s√©quentielle**, s√©par√©s par des virgules et envelopp√©s entre crochets pour les chaines de caract√®res. Pour cr√©er une liste, il suffit d'encadrer une s√©rie d'√©l√©ments avec des crochets, s√©par√©s par des virgules, par exemple : [\"Bonjour\", \"Au revoir\", 75]. L'acc√®s aux √©l√©ments se fait en utilisant leur index, en commen√ßant par 0. √âtant donn√© que les listes sont **mutables**, il est possible de modifier leurs √©l√©ments **apr√®s leur cr√©ation**.\n</p>\n\n```{python}\n\n# D√©finition d'une liste\nmaListe = [1, 2, 3, \"a\", \"b\", \"c\"]\nprint(maListe)\n\n# Acc√®s au premier et au dernier √©l√©ment\npremierElement = maListe[0]\ndernierElement = maListe[-1]\nprint(premierElement, \"\\n\", dernierElement)\n\n# Modification du deuxi√®me √©l√©ment\nmaListe[1] = \"deux\" \nprint(maListe)\n\n# Concat√©nation et R√©p√©tition\ncombinee = maListe + [\"autre\", \"liste\"]\nprint(combinee)\n\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n\n```\n\n##### Le Slicing\n<p id=textIntro>En plus de permettre l'acc√®s aux √©l√©ments d'une liste un par un, Python propose une syntaxe concise appel√©e **slicing** pour acc√©der aux sous-listes.</p>\n\n```{python}\n\n# D√©finition d'une liste\nmaListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers\n\n# Acc√®s √† une sous-liste en utilisant le slicing\nsousListe1 = maListe[1:3]  # R√©cup√®re les √©l√©ments de l'index 1 inclus jusqu'√† l'index 3 non inclus\nsousListe2 = maListe[:3]   # R√©cup√®re les trois premiers √©l√©ments de la liste\nsousListe3 = maListe[2:]   # R√©cup√®re les √©l√©ments √† partir de l'index 2 jusqu'√† la fin de la liste\nsousListe4 = maListe[::2]  # R√©cup√®re les √©l√©ments avec un pas de 2\n\n# Affichage des sous-listes\nprint(\"Sous-liste 1:\", sousListe1)  # R√©sultat : [1, 2]\nprint(\"Sous-liste 2:\", sousListe2)  # R√©sultat : [0, 1, 2]\nprint(\"Sous-liste 3:\", sousListe3)  # R√©sultat : [2, 3, 4]\nprint(\"Sous-liste 4:\", sousListe4)  # R√©sultat : [0, 2, 4]\n\n# Exemples de mutations de listes :\n\n# Cas 1: source de m√™me longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]  # Remplace la sous-liste √† partir de l'index 1 par [4, 5]\nprint(nums1)  # R√©sultat : [1, 4, 5]\n\n# Cas 2: source de longueur diff√©rente\nnums2 = nums1\nnums2[1:] = [6]  # Remplace la sous-liste √† partir de l'index 1 par [6]\nprint(nums2)  # R√©sultat : [1, 6]\n\n# V√©rification si les deux listes pointent vers le m√™me objet en m√©moire\nisSameObject = id(nums1) == id(nums2)  # V√©rifie si les listes pointent vers le m√™me objet\nprint(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifi√©es en place\n```\n\n##### Les m√©thodes de listes\n<p id=textIntro>Chaque m√©thode offre une fonctionnalit√© unique pour manipuler des listes, rendant ces structures de donn√©es\nextr√™mement flexibles et puissantes pour une vari√©t√© de t√¢ches en programmation Python.</p>\n\n| **M√©thode** | **Description** | **Exemple d'Utilisation** |\n| --- | --- | --- |\n| **append()** | Ajoute **un √©l√©ment** √† la fin de la liste. | liste.append(5) |\n| **extend()** | √âtend la liste en ajoutant **tous les √©l√©ments d'une autre liste**. | liste.extend([6, 7]) |\n| **insert()** | Ins√®re un √©l√©ment √† une position donn√©e. | liste.insert(1, 'a') |\n| **remove()** | Supprime la premi√®re occurrence d'un √©l√©ment. | liste.remove('a') |\n| **pop()** | Supprime et renvoie un √©l√©ment √† une position donn√©e (par d√©faut, le dernier). | liste.pop() |\n| **clear()** | Supprime tous les √©l√©ments de la liste. | liste.clear() |\n| **index()** | Retourne l'indice du premier √©l√©ment correspondant. | liste.index('a') |\n| **count()** | Compte le nombre d'occurrences d'un √©l√©ment sp√©cifique. | liste.count(5) |\n| **sort()** | Trie les √©l√©ments de la liste (dans un ordre sp√©cifique). | liste.sort() |\n| **reverse()** | Inverse l'ordre des √©l√©ments de la liste. | liste.reverse() |\n\n```{python}\n# Cr√©ation d'une liste de base\nmaListe = [1, 2, 3]\nprint(maListe)\n\n# Ajout d'un √©l√©ment √† la fin de la liste avec append()\nmaListe.append(\"quatre\")\nprint(\"Apr√®s append(quatre):\", maListe)\n\n# Extension de la liste en ajoutant les √©l√©ments d'une autre liste avec extend()\nmaListe.extend([5, 6])\nprint(\"Apr√®s extend([5, 6]):\", maListe)\n\n# Insertion d'un √©l√©ment √† un index sp√©cifique avec insert()\nmaListe.insert(1, 'elephant')\nprint(\"Apr√®s insert(1, 'elephant'):\", maListe)\n\n# Suppression de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec remove()\nmaListe.remove('elephant')\nprint(\"Apr√®s remove('elephant'):\", maListe)\n\n# Suppression et retour de l'√©l√©ment √† la fin de la liste avec pop()\nelementSupprime = maListe.pop()\nprint(\"Apr√®s pop():\", maListe, \", √âl√©ment supprim√©:\", elementSupprime)\n\n# Suppression de tous les √©l√©ments de la liste avec clear()\nmaListe.clear()\nprint(\"Apr√®s clear():\", maListe)\n\n# Recr√©ation de la liste pour les autres m√©thodes\nmaListe = [3, 1, 4, 2, 2]\n\n# Recherche de l'index de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec index()\nindexDe4 = maListe.index(4)\nprint(\"Index de 4:\", indexDe4)\n\n# Comptage du nombre d'occurrences d'un √©l√©ment sp√©cifi√© avec count()\ncompteDe2 = maListe.count(2)\nprint(\"Nombre d'occurrences de 2:\", compteDe2)\n\n# Tri des √©l√©ments de la liste dans l'ordre croissant avec sort()\nmaListe.sort()\nprint(\"Apr√®s sort():\", maListe)\n\n# Inversion de l'ordre des √©l√©ments dans la liste avec reverse()\nmaListe.reverse()\nprint(\"Apr√®s reverse():\", maListe)\n\n```\n\n##### Parcours de liste\n<p id=textIntro> Le parcours de liste consiste √† acc√©der s√©quentiellement √† chaque √©l√©ment d'une liste. Cela peut √™tre fait de diff√©rentes\nmani√®res, mais les plus courantes sont les boucles **for** et **while** .</p>\n\n* Boucle for : : La boucle for est la m√©thode la plus couramment utilis√©e pour parcourir une liste. Elle permet de traiter chaque √©l√©ment\nindividuellement.\n\n* List Comprehension : La compr√©hension de liste est une m√©thode concise pour cr√©er des listes. Elle permet de transformer une liste en\nune autre liste, en filtrant les √©l√©ments pour former une liste des r√©sultats d'une expression donn√©e\n\n<p id=textIntro> La syntaxe de base d'une compr√©hension de liste est :\n**[**``nouvelle_expression`` **for ``item`` **in** ``iterable`` **if** ``condition``**]**\n<ul>\n<li><p id=textIntro>**nouvelle_expression** est l'expression qui d√©finit comment **mapper** les √©l√©ments de l' iterable (par exemple, une liste).</p></li>\n<li><p id=textIntro>**item** est la variable qui prend la valeur de chaque √©l√©ment de l' iterable pendant chaque it√©ration.</p></li>\n<li><p id=textIntro> **condition** est une condition optionnelle pour filtrer les √©l√©ments de l' iterable. </p>\n</li>\n</ul>\n<p id=textIntro>Nous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une **list comprehension** :</p>\n\n```{python}\n\n# r√©cup√©rer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nautreListe = []\nautreListe2 = []\n\n# Avec une boucle for\nfor f in fruits:\n    if \"a\" in f:\n        autreListe.append(f)\nprint(autreListe)\n\n# Avec une list comprehension\nautreListe2 = [f for f in fruits if \"a\" in f ]\nprint(autreListe2)\n\n\n```\n\n<p id=textIntro>Nous pouvons voir que **les list comprehension** sont un moyen d'√©crire un code plus concis mais toujours autant compr√©hensible ! Alors pourquoi se prendre la t√™te avec une boucle for ? üòé\n<br>\nElles peuvent aussi √™tre utilis√©es pour effectuer des calculs sur tous les √©l√©ments d'une liste. Voyons √ßa :</p>\n\n```{python}\n# Elevation des nombres d'une liste au carr√©\nnombres = [2, 5, 10, 111]\nnombreCarres = [x**2 for x in nombres]\nprint(nombreCarres) # [4, 25, 100, 12321]\n\n# Filtrer les nombres pairs d'une liste\ncarresPairs = [x for x in nombreCarres if x%2==0]\nprint(carresPairs)\n\n# Appliquer une m√©thode √† tous les √©l√©ments\nfruits_majuscule = [fruit.upper() for fruit in fruits]\nprint(fruits_majuscule)\n\n```\n\n#### Les tuples\n\n<p id=textIntro>Les tuples sont des listes **non mutables**. Cela signifie que les √©l√©ments d'un tuple ne peuvent pas √™tre modifi√©s apr√®s cr√©ation. Les √©l√©ments sont s√©par√©s par d√© virgules et sont entour√©s de parenth√®ses.</p>\n\n| **Avantage**                      | **Description**                                               |\n|------------------------------|-----------------------------------------------------------|\n| **S√©curit√© des Donn√©es**         | Parfait pour prot√©ger les donn√©es contre les modifications. |\n| **Performance**                  | Plus rapides √† parcourir que les listes.                 |\n| **Utilisation en tant que Cl√©s de Dictionnaire** | Peuvent √™tre utilis√©s comme cl√©s dans les dictionnaires, contrairement aux listes. |\n| **Retour de Plusieurs Valeurs de Fonction** | Utilis√©s pour retourner plusieurs valeurs depuis une fonction. |\n| **Stockage de Donn√©es Constantes** | Id√©aux pour stocker des donn√©es qui ne doivent pas √™tre modifi√©es. |\n\n```{python}\n# D√©finition d'un tuple\nmonTuple = (10, \"b\", 3.14)\nprint(monTuple)\n\nunAutreTuple = 20, \"c\", 4.28\nprint(unAutreTuple)\n\nelementIndex1 = monTuple[1]\nprint(elementIndex1)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = 50,\nprint(tupleSingleton)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = (50,)\n\n# Imbrication\ntupleImbrique = (10, (20, 30), (40, 50))\n\n# M√©thodes Utiles\nlongueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3\nprint(longueur)\n\ncompteur = monTuple.count(\"b\")  # Compte le nombre de fois que \"b\" appara√Æt dans monTuple, ici 1\nprint(compteur)\n\nindice = monTuple.index(\"b\")  # Trouve l'indice de \"b\" dans monTuple, ici 1\nprint(indice)\n\n# L'affectation n'est pas possible\n# monTuple[1] = \"c\"\n\n```\n\n#### Les ensembles\n<p id=textIntro>Les ensembles sont :</p>\n\n* Des collections non ordonn√©es de **valeurs uniques**\n\n* **Mutables**, mais chaque √©l√©ment doit √™tre **unique**.\n\n* **Non-Ordonn√©s** : Les ensembles ne **maintiennent pas** l'ordre des √©l√©ments. On ne peut donc pas acc√©der aux √©l√©ments par un index.\n\n* Les √©l√©ments sont s√©par√©s par des virgules, et encadr√©s par des accolades\n\n##### Op√©rations sur les ensembles\n\n| **Op√©ration**         | **Syntaxe**    | Description                                                                              |\n|-----------------------|---------------|------------------------------------------------------------------------------------------|\n| **Union**             | **a \\| b**    | Retourne un nouvel ensemble contenant tous les √©l√©ments uniques des ensembles a et b.   |\n| **Intersection**      | **a & b**     | Retourne un nouvel ensemble contenant uniquement les √©l√©ments communs aux ensembles a et b. |\n| **Diff√©rence**        | **a - b**     | Retourne un nouvel ensemble contenant les √©l√©ments de a qui ne sont pas dans b.          |\n| **Diff√©rence Sym√©trique** | **a ^ b** | Retourne un nouvel ensemble contenant tous les √©l√©ments qui sont dans a ou b, mais pas dans les deux. |\n| **Ajout**             | **a.add(x)**  | Ajoute l'√©l√©ment x √† l'ensemble a.                                                     |\n| **Suppression**       | **a.remove(x)**| Supprime l'√©l√©ment x de l'ensemble a ; **l√®ve une erreur si x n'est pas pr√©sent**.           |\n| **Suppression (sans erreur)** | **a.discard(x)** | Supprime l'√©l√©ment x de l'ensemble a si x est pr√©sent ; **ne fait rien sinon**.           |\n\n#### Les dictionnaires\n\n<p id=textIntro>Les dictionnaires sont un peu comme un format de JSON :</p>\n\n* Ils sont bas√©s sur des paires **cl√©s-valeurs**\n* On acc√®de aux valeurs via les **cl√©s**\n* Ils sont **mutables**, on peut y **ajouter** des √©l√©ments, en **supprimer** ou en **modifier**\n*   \n* Utilisation :\n- **Stockage d'Informations Structur√©es** : Parfait pour stocker des informations complexes comme des donn√©es utilisateur.\n- **Recherche Rapide** : Utilisez des dictionnaires pour des recherches rapides bas√©es sur des cl√©s uniques\n\n<p id=textIntro>Il existe des m√©thodes li√©es aux variables de type dictionnaire pour les manier :</p>\n\n| M√©thode                | Description                                                                                   |\n|------------------------|-----------------------------------------------------------------------------------------------|\n| **`dict.keys()`**      | Retourne une vue sur les cl√©s du dictionnaire.                                               |\n| **`dict.values()`**    | Retourne une vue sur les valeurs du dictionnaire.                                            |\n| **`dict.items()`**     | Retourne une vue sur les paires (cl√©, valeur) du dictionnaire.                               |\n| **`dict.get(key)`**    | Retourne la valeur associ√©e √† la cl√© sp√©cifi√©e.                                               |\n|                        | Si la cl√© n'existe pas, retourne `None` ou une valeur par d√©faut sp√©cifi√©e en argument.       |\n| **`dict.pop(key)`**    | Retourne la valeur associ√©e √† la cl√© sp√©cifi√©e et supprime cette paire du dictionnaire.\n|                        | Si la cl√© n'existe pas, retourne une valeur par d√©faut sp√©cifi√©e en argument ou l√®ve une erreur.                                                                             |\n| **`dict.popitem()`**  | Retourne et supprime une paire (cl√©, valeur) arbitraire du dictionnaire.                     |\n| **`dict.update(other_dict)`** | Met √† jour le dictionnaire avec les paires cl√©-valeur du dictionnaire sp√©cifi√© en argument. |\n| **`dict.clear()`**     | Supprime toutes les paires cl√©-valeur du dictionnaire, le laissant vide.                      |\n\n```{python}\n# Cr√©ation d'un dictionnaire\nindividu = {\"nom\": \"Alice\", \"age\": 30}\nautre_dictionnaire = dict(nom=\"Bob\", age=25)\nindividu\n\n# Ajout et mise √† jour\nindividu[\"profession\"] = \"D√©veloppeur\"\nindividu\n\n# Mise √† jour de plusieurs cl√©s\nindividu.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\nindividu\n\n# Utilisation de keys()\ncles = individu.keys()\nprint(\"Cl√©s:\", cles)\n\n# Utilisation de values()\nvaleurs = individu.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = individu.items()\nprint(\"Paires cl√©-valeur:\", paires)\n\n# Utilisation de get()\nnom_personne = individu.get(\"nom\")\nage_personne = individu.get(\"age\")\nprint(nom_personne, age_personne)\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\"\nville = individu.get(\"ville\")\nville\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\" avec une valeur par d√©faut\nville = individu.get(\"ville\", \"Non sp√©cifi√©e\")\nprint(\"Ville:\", ville)\n\n# Parcours des cl√©s\nprint(\"\\nParcours des cl√©s:\")\nfor cle in individu.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in individu.values():\n    print(valeur)\n\n# Parcours des paires cl√©-valeur\nprint(\"\\nParcours des paires cl√©-valeur:\")\nfor cle, valeur in individu.items():\n    print(cle, \":\", valeur)\n\n# Parcours des paires cl√©-valeur avec enumerate\nprint(\"\\nParcours des paires cl√©-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(individu.items()):\n    print(f\"Index {index}: Cl√© = {cle}, Valeur = {valeur}\")\n\n# Suppression d'une cl√© et de sa valeur\ndel individu[\"age\"]\nprint(individu)\n\n# Suppression d'une cl√© avec retour de sa valeur\nprofession = individu.pop(\"profession\")\nprint(profession)\n\n# Suppression d'une cl√© avec retour de sa valeur et gestion de l'absence de la cl√©\nville_supprimee = individu.pop(\"ville\", \"Non sp√©cifi√©e\")\nprint(ville_supprimee)\n\n# Affichage du dictionnaire apr√®s les suppressions\nprint(individu)\n\n\n```\n\n<p id=textIntro>Vous √™tes maintenant des pros des donn√©es s√©quentielles ! Pensez-vous que cela suffit ? Continuez de vous instruire en <a href=comm_affiche.qmd>cliquant ici</a> pour passer √† la suite.</p>\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"types_donnees.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","theme":"zephyr","title":"Types de donn√©es"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}