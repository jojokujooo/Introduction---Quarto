{
  "hash": "b87a150201e4925226a5b32d9b1fd2a9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Types de données\n---\n\n### Types de Données (Structures séquentielles)\n\n<p id=textIntro>Chaque type de données séquentielles offre des caractéristiques distinctes et des utilisations spécifiques, permettant une grande souplesse dans le traitement des données. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilité et leurs capacités de stockage dynamique, les rendant particulièrement populaires dans de nombreux scénarios d'utilisation.</p>\n\n#### Les Chaines de Caractères\n\n<p id=textIntro>\nLes **chaînes de caractères (str)** sont utilisées pour stocker et manipuler du texte. Elles peuvent être définies en encadrant le texte entre des guillemets **simples** ('...'), **doubles** (\"...\"), ou **triples** ('''...''' ou \"\"\"...\"\"\") pour les chaînes multilignes. <br>\nLes chaînes sont des séquences de caractères **indexées à partir de 0** et peuvent contenir des caractères spéciaux, comme des guillemets, grâce aux caractères d'échappement (\\). Les chaînes de caractères offrent une gamme complète de méthodes pour le traitement de texte, les rendant extrêmement polyvalentes et **indispensables** pour une variété d'applications, de manipulations de base à des opérations plus complexes. Voici quelques exemples :\n</p>\n\n::: {#4e5155d0 .cell execution_count=1}\n``` {.python .cell-code}\n# Exemples de chaines de caractères\n# Chaine de caractères simple\nmaChaine = 'Python est un langage de programmation'\n\n# Chaine de caractères double\nmaChaine2 = \"Python est un langage de programmation\"\n\n# Chaine avec un caractère d'échappement\nmaChaine3 = 'Python c\\'est trop bien'\n\nprint(maChaine)\nprint(maChaine2)\nprint(maChaine3)\n\n# On peut accéder à des éléments\n# Premier caractère\npremierCaractere = maChaine[0] # 'P'\n# Dernier caractère\ndernierCaractere = maChaine[-1] # 'n'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPython est un langage de programmation\nPython est un langage de programmation\nPython c'est trop bien\n```\n:::\n:::\n\n\n<p id=textIntro> \nLes méthodes sont des fonctions associées à des objets spécifiques, leur permettant d'exécuter des actions sur ces objets ou de manipuler leurs données internes. Contrairement aux fonctions indépendantes, les méthodes sont liées à des objets particuliers.\n<br> Par exemple, les méthodes des **chaînes de caractères (str)** sont conçues pour **opérer sur des chaînes de caractères spécifiques**. Elles sont appelées en utilisant la notation pointée, comme **objet.methode()**. Les méthodes de chaînes de caractères incluent des fonctionnalités telles que **upper()**, **lower()**, et **replace()**, permettant de convertir en majuscules, en minuscules ou de remplacer des parties spécifiques de la chaîne. Pour appeler une méthode, utilisez généralement la syntaxe objet.methode(arguments).\n<br>\nPour utiliser ces méthodes vous pouvez les utiliser sur des variables contenant une chaine de caractères ou sur des chaines de caractères directement.\n</p>\n\n::: {#8b12f826 .cell execution_count=2}\n``` {.python .cell-code}\n# Méthodes pour les chaînes de caractères\n\n# isupper() et islower()\n\nchaineMaj = \"PYTHON\"\nchaineMin = \"python\"\nestMajuscule = chaineMaj.isupper()\nestMinuscule = chaineMin.islower()\nprint(estMajuscule) # Résultat : True\nprint(estMinuscule) # Résultat : True\n\n# upper() et lower()\nchaine = \"python est génial\"\nminToMaj = chaine.upper()\nprint(minToMaj) # Résultat : \"PYTHON EST GÉNIAL\"\n\nmajToMin = \"PYTHON est GÉNIAL\".lower()\nprint(majToMin) # Résultat : \"python est génial\"\n\nchaineCapitalize = chaine.capitalize() # La première lettre est en majuscule\nprint(chaineCapitalize) # Résultat : \"Python est génial\"\n\nchaineTitle = chaine.title() # La première lettre de chaque mot est en majuscule\nprint(chaineTitle) # Résultat : \"Python Est Génial\"\n\nposition = chaine.find(\"est\") # La méthode find() renvoie l'index de la première occurrence de la chaîne recherchée\nprint(position) # Résultat : 7\n\nchaineReplace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\") # La méthode replace() remplace une chaîne par une autre\nprint(chaineReplace) # Résultat : \"Les bananes sont rouges.\"\n\nchaineSplit = chaine.split(\" \") # La méthode split() découpe une chaîne en une liste de sous-chaînes\nprint(chaineSplit) # Résultat : [\"python\", \"est\", \"genial\"]\n\nelements = [\"apple\", \"orange\", \"banana\"]\ntextJoin = \", \".join(elements) # La méthode join() concatène les éléments d'une liste\nprint(textJoin) # Résultat : \"apple, orange, banana\"\n\ntextStrip = \" Bonjour \".strip() # La méthode strip() supprime les espaces en début et fin de chaîne\nprint(textStrip) # Résultat : \"Bonjour\"\n\nchaineStartsWith = chaine.startswith(\"Python\")\nprint(chaineStartsWith) # Résultat : True\n\nchaineEndsWith = chaine.endswith(\"génial\")\nprint(chaineEndsWith) # Résultat : True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nPYTHON EST GÉNIAL\npython est génial\nPython est génial\nPython Est Génial\n7\nLes bananes sont rouges.\n['python', 'est', 'génial']\napple, orange, banana\nBonjour\nFalse\nTrue\n```\n:::\n:::\n\n\n#### Les listes\n<p id=textIntro>\nLes listes représentent des **structures de données** permettant de stocker une **séquence d'éléments**. Elles offrent une grande souplesse, car elles peuvent contenir des éléments de types variés et sont modifiables. En tant que collections ordonnées, les éléments sont organisés de manière **séquentielle**, séparés par des virgules et enveloppés entre crochets pour les chaines de caractères. Pour créer une liste, il suffit d'encadrer une série d'éléments avec des crochets, séparés par des virgules, par exemple : [\"Bonjour\", \"Au revoir\", 75]. L'accès aux éléments se fait en utilisant leur index, en commençant par 0. Étant donné que les listes sont **mutables**, il est possible de modifier leurs éléments **après leur création**.\n</p>\n\n::: {#443ac720 .cell execution_count=3}\n``` {.python .cell-code}\n# Définition d'une liste\nmaListe = [1, 2, 3, \"a\", \"b\", \"c\"]\nprint(maListe)\n\n# Accès au premier et au dernier élément\npremierElement = maListe[0]\ndernierElement = maListe[-1]\nprint(premierElement, \"\\n\", dernierElement)\n\n# Modification du deuxième élément\nmaListe[1] = \"deux\" \nprint(maListe)\n\n# Concaténation et Répétition\ncombinee = maListe + [\"autre\", \"liste\"]\nprint(combinee)\n\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 'a', 'b', 'c']\n1 \n c\n[1, 'deux', 3, 'a', 'b', 'c']\n[1, 'deux', 3, 'a', 'b', 'c', 'autre', 'liste']\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n:::\n:::\n\n\n##### Le Slicing\n<p id=textIntro>En plus de permettre l'accès aux éléments d'une liste un par un, Python propose une syntaxe concise appelée **slicing** pour accéder aux sous-listes.</p>\n\n::: {#3111a7fd .cell execution_count=4}\n``` {.python .cell-code}\n# Définition d'une liste\nmaListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers\n\n# Accès à une sous-liste en utilisant le slicing\nsousListe1 = maListe[1:3]  # Récupère les éléments de l'index 1 inclus jusqu'à l'index 3 non inclus\nsousListe2 = maListe[:3]   # Récupère les trois premiers éléments de la liste\nsousListe3 = maListe[2:]   # Récupère les éléments à partir de l'index 2 jusqu'à la fin de la liste\nsousListe4 = maListe[::2]  # Récupère les éléments avec un pas de 2\n\n# Affichage des sous-listes\nprint(\"Sous-liste 1:\", sousListe1)  # Résultat : [1, 2]\nprint(\"Sous-liste 2:\", sousListe2)  # Résultat : [0, 1, 2]\nprint(\"Sous-liste 3:\", sousListe3)  # Résultat : [2, 3, 4]\nprint(\"Sous-liste 4:\", sousListe4)  # Résultat : [0, 2, 4]\n\n# Exemples de mutations de listes :\n\n# Cas 1: source de même longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]  # Remplace la sous-liste à partir de l'index 1 par [4, 5]\nprint(nums1)  # Résultat : [1, 4, 5]\n\n# Cas 2: source de longueur différente\nnums2 = nums1\nnums2[1:] = [6]  # Remplace la sous-liste à partir de l'index 1 par [6]\nprint(nums2)  # Résultat : [1, 6]\n\n# Vérification si les deux listes pointent vers le même objet en mémoire\nisSameObject = id(nums1) == id(nums2)  # Vérifie si les listes pointent vers le même objet\nprint(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifiées en place\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSous-liste 1: [1, 2]\nSous-liste 2: [0, 1, 2]\nSous-liste 3: [2, 3, 4]\nSous-liste 4: [0, 2, 4]\n[1, 4, 5]\n[1, 6]\nTrue\n```\n:::\n:::\n\n\n##### Les méthodes de listes\n<p id=textIntro>Chaque méthode offre une fonctionnalité unique pour manipuler des listes, rendant ces structures de données\nextrêmement flexibles et puissantes pour une variété de tâches en programmation Python.</p>\n\n| **Méthode** | **Description** | **Exemple d'Utilisation** |\n| --- | --- | --- |\n| **append()** | Ajoute **un élément** à la fin de la liste. | liste.append(5) |\n| **extend()** | Étend la liste en ajoutant **tous les éléments d'une autre liste**. | liste.extend([6, 7]) |\n| **insert()** | Insère un élément à une position donnée. | liste.insert(1, 'a') |\n| **remove()** | Supprime la première occurrence d'un élément. | liste.remove('a') |\n| **pop()** | Supprime et renvoie un élément à une position donnée (par défaut, le dernier). | liste.pop() |\n| **clear()** | Supprime tous les éléments de la liste. | liste.clear() |\n| **index()** | Retourne l'indice du premier élément correspondant. | liste.index('a') |\n| **count()** | Compte le nombre d'occurrences d'un élément spécifique. | liste.count(5) |\n| **sort()** | Trie les éléments de la liste (dans un ordre spécifique). | liste.sort() |\n| **reverse()** | Inverse l'ordre des éléments de la liste. | liste.reverse() |\n\n::: {#45ec986a .cell execution_count=5}\n``` {.python .cell-code}\n# Création d'une liste de base\nmaListe = [1, 2, 3]\nprint(maListe)\n\n# Ajout d'un élément à la fin de la liste avec append()\nmaListe.append(\"quatre\")\nprint(\"Après append(quatre):\", maListe)\n\n# Extension de la liste en ajoutant les éléments d'une autre liste avec extend()\nmaListe.extend([5, 6])\nprint(\"Après extend([5, 6]):\", maListe)\n\n# Insertion d'un élément à un index spécifique avec insert()\nmaListe.insert(1, 'elephant')\nprint(\"Après insert(1, 'elephant'):\", maListe)\n\n# Suppression de la première occurrence d'un élément spécifié avec remove()\nmaListe.remove('elephant')\nprint(\"Après remove('elephant'):\", maListe)\n\n# Suppression et retour de l'élément à la fin de la liste avec pop()\nelementSupprime = maListe.pop()\nprint(\"Après pop():\", maListe, \", Élément supprimé:\", elementSupprime)\n\n# Suppression de tous les éléments de la liste avec clear()\nmaListe.clear()\nprint(\"Après clear():\", maListe)\n\n# Recréation de la liste pour les autres méthodes\nmaListe = [3, 1, 4, 2, 2]\n\n# Recherche de l'index de la première occurrence d'un élément spécifié avec index()\nindexDe4 = maListe.index(4)\nprint(\"Index de 4:\", indexDe4)\n\n# Comptage du nombre d'occurrences d'un élément spécifié avec count()\ncompteDe2 = maListe.count(2)\nprint(\"Nombre d'occurrences de 2:\", compteDe2)\n\n# Tri des éléments de la liste dans l'ordre croissant avec sort()\nmaListe.sort()\nprint(\"Après sort():\", maListe)\n\n# Inversion de l'ordre des éléments dans la liste avec reverse()\nmaListe.reverse()\nprint(\"Après reverse():\", maListe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\nAprès append(quatre): [1, 2, 3, 'quatre']\nAprès extend([5, 6]): [1, 2, 3, 'quatre', 5, 6]\nAprès insert(1, 'elephant'): [1, 'elephant', 2, 3, 'quatre', 5, 6]\nAprès remove('elephant'): [1, 2, 3, 'quatre', 5, 6]\nAprès pop(): [1, 2, 3, 'quatre', 5] , Élément supprimé: 6\nAprès clear(): []\nIndex de 4: 2\nNombre d'occurrences de 2: 2\nAprès sort(): [1, 2, 2, 3, 4]\nAprès reverse(): [4, 3, 2, 2, 1]\n```\n:::\n:::\n\n\n##### Parcours de liste\n<p id=textIntro> Le parcours de liste consiste à accéder séquentiellement à chaque élément d'une liste. Cela peut être fait de différentes\nmanières, mais les plus courantes sont les boucles **for** et **while** .</p>\n\n* Boucle for : : La boucle for est la méthode la plus couramment utilisée pour parcourir une liste. Elle permet de traiter chaque élément\nindividuellement.\n\n* List Comprehension : La compréhension de liste est une méthode concise pour créer des listes. Elle permet de transformer une liste en\nune autre liste, en filtrant les éléments pour former une liste des résultats d'une expression donnée\n\n<p id=textIntro> La syntaxe de base d'une compréhension de liste est :\n**[**``nouvelle_expression`` **for ``item`` **in** ``iterable`` **if** ``condition``**]**\n<ul>\n<li><p id=textIntro>**nouvelle_expression** est l'expression qui définit comment **mapper** les éléments de l' iterable (par exemple, une liste).</p></li>\n<li><p id=textIntro>**item** est la variable qui prend la valeur de chaque élément de l' iterable pendant chaque itération.</p></li>\n<li><p id=textIntro> **condition** est une condition optionnelle pour filtrer les éléments de l' iterable. </p>\n</li>\n</ul>\n<p id=textIntro>Nous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une **list comprehension** :</p>\n\n::: {#7567d458 .cell execution_count=6}\n``` {.python .cell-code}\n# récupérer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nautreListe = []\nautreListe2 = []\n\n# Avec une boucle for\nfor f in fruits:\n    if \"a\" in f:\n        autreListe.append(f)\nprint(autreListe)\n\n# Avec une list comprehension\nautreListe2 = [f for f in fruits if \"a\" in f ]\nprint(autreListe2)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['apple', 'banana', 'mango']\n['apple', 'banana', 'mango']\n```\n:::\n:::\n\n\n<p id=textIntro>Nous pouvons voir que **les list comprehension** sont un moyen d'écrire un code plus concis mais toujours autant compréhensible ! Alors pourquoi se prendre la tête avec une boucle for ? 😎\n<br>\nElles peuvent aussi être utilisées pour effectuer des calculs sur tous les éléments d'une liste. Voyons ça :</p>\n\n::: {#c66152e2 .cell execution_count=7}\n``` {.python .cell-code}\n# Elevation des nombres d'une liste au carré\nnombres = [2, 5, 10, 111]\nnombreCarres = [x**2 for x in nombres]\nprint(nombreCarres) # [4, 25, 100, 12321]\n\n# Filtrer les nombres pairs d'une liste\ncarresPairs = [x for x in nombreCarres if x%2==0]\nprint(carresPairs)\n\n# Appliquer une méthode à tous les éléments\nfruits_majuscule = [fruit.upper() for fruit in fruits]\nprint(fruits_majuscule)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4, 25, 100, 12321]\n[4, 100]\n['APPLE', 'BANANA', 'CHERRY', 'KIWI', 'MANGO']\n```\n:::\n:::\n\n\n#### Les tuples\n\n<p id=textIntro>Les tuples sont des listes **non mutables**. Cela signifie que les éléments d'un tuple ne peuvent pas être modifiés après création. Les éléments sont séparés par dé virgules et sont entourés de parenthèses.</p>\n\n| **Avantage**                      | **Description**                                               |\n|------------------------------|-----------------------------------------------------------|\n| **Sécurité des Données**         | Parfait pour protéger les données contre les modifications. |\n| **Performance**                  | Plus rapides à parcourir que les listes.                 |\n| **Utilisation en tant que Clés de Dictionnaire** | Peuvent être utilisés comme clés dans les dictionnaires, contrairement aux listes. |\n| **Retour de Plusieurs Valeurs de Fonction** | Utilisés pour retourner plusieurs valeurs depuis une fonction. |\n| **Stockage de Données Constantes** | Idéaux pour stocker des données qui ne doivent pas être modifiées. |\n\n::: {#d8e5f2c6 .cell execution_count=8}\n``` {.python .cell-code}\n# Définition d'un tuple\nmonTuple = (10, \"b\", 3.14)\nprint(monTuple)\n\nunAutreTuple = 20, \"c\", 4.28\nprint(unAutreTuple)\n\nelementIndex1 = monTuple[1]\nprint(elementIndex1)\n\n# Tuple à Un Élément\ntupleSingleton = 50,\nprint(tupleSingleton)\n\n# Tuple à Un Élément\ntupleSingleton = (50,)\n\n# Imbrication\ntupleImbrique = (10, (20, 30), (40, 50))\n\n# Méthodes Utiles\nlongueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3\nprint(longueur)\n\ncompteur = monTuple.count(\"b\")  # Compte le nombre de fois que \"b\" apparaît dans monTuple, ici 1\nprint(compteur)\n\nindice = monTuple.index(\"b\")  # Trouve l'indice de \"b\" dans monTuple, ici 1\nprint(indice)\n\n# L'affectation n'est pas possible\n# monTuple[1] = \"c\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(10, 'b', 3.14)\n(20, 'c', 4.28)\nb\n(50,)\n3\n1\n1\n```\n:::\n:::\n\n\n#### Les ensembles\n<p id=textIntro>Les ensembles sont :</p>\n\n* Des collections non ordonnées de **valeurs uniques**\n\n* **Mutables**, mais chaque élément doit être **unique**.\n\n* **Non-Ordonnés** : Les ensembles ne **maintiennent pas** l'ordre des éléments. On ne peut donc pas accéder aux éléments par un index.\n\n* Les éléments sont séparés par des virgules, et encadrés par des accolades\n\n##### Opérations sur les ensembles\n\n| **Opération**         | **Syntaxe**    | Description                                                                              |\n|-----------------------|---------------|------------------------------------------------------------------------------------------|\n| **Union**             | **a \\| b**    | Retourne un nouvel ensemble contenant tous les éléments uniques des ensembles a et b.   |\n| **Intersection**      | **a & b**     | Retourne un nouvel ensemble contenant uniquement les éléments communs aux ensembles a et b. |\n| **Différence**        | **a - b**     | Retourne un nouvel ensemble contenant les éléments de a qui ne sont pas dans b.          |\n| **Différence Symétrique** | **a ^ b** | Retourne un nouvel ensemble contenant tous les éléments qui sont dans a ou b, mais pas dans les deux. |\n| **Ajout**             | **a.add(x)**  | Ajoute l'élément x à l'ensemble a.                                                     |\n| **Suppression**       | **a.remove(x)**| Supprime l'élément x de l'ensemble a ; **lève une erreur si x n'est pas présent**.           |\n| **Suppression (sans erreur)** | **a.discard(x)** | Supprime l'élément x de l'ensemble a si x est présent ; **ne fait rien sinon**.           |\n\n#### Les dictionnaires\n\n<p id=textIntro>Les dictionnaires sont un peu comme un format de JSON :</p>\n\n* Ils sont basés sur des paires **clés-valeurs**\n* On accède aux valeurs via les **clés**\n* Ils sont **mutables**, on peut y **ajouter** des éléments, en **supprimer** ou en **modifier**\n*   \n* Utilisation :\n- **Stockage d'Informations Structurées** : Parfait pour stocker des informations complexes comme des données utilisateur.\n- **Recherche Rapide** : Utilisez des dictionnaires pour des recherches rapides basées sur des clés uniques\n\n<p id=textIntro>Il existe des méthodes liées aux variables de type dictionnaire pour les manier :</p>\n\n| Méthode                | Description                                                                                   |\n|------------------------|-----------------------------------------------------------------------------------------------|\n| **`dict.keys()`**      | Retourne une vue sur les clés du dictionnaire.                                               |\n| **`dict.values()`**    | Retourne une vue sur les valeurs du dictionnaire.                                            |\n| **`dict.items()`**     | Retourne une vue sur les paires (clé, valeur) du dictionnaire.                               |\n| **`dict.get(key)`**    | Retourne la valeur associée à la clé spécifiée.                                               |\n|                        | Si la clé n'existe pas, retourne `None` ou une valeur par défaut spécifiée en argument.       |\n| **`dict.pop(key)`**    | Retourne la valeur associée à la clé spécifiée et supprime cette paire du dictionnaire.\n|                        | Si la clé n'existe pas, retourne une valeur par défaut spécifiée en argument ou lève une erreur.                                                                             |\n| **`dict.popitem()`**  | Retourne et supprime une paire (clé, valeur) arbitraire du dictionnaire.                     |\n| **`dict.update(other_dict)`** | Met à jour le dictionnaire avec les paires clé-valeur du dictionnaire spécifié en argument. |\n| **`dict.clear()`**     | Supprime toutes les paires clé-valeur du dictionnaire, le laissant vide.                      |\n\n::: {#45c18319 .cell execution_count=9}\n``` {.python .cell-code}\n# Création d'un dictionnaire\nindividu = {\"nom\": \"Alice\", \"age\": 30}\nautre_dictionnaire = dict(nom=\"Bob\", age=25)\nindividu\n\n# Ajout et mise à jour\nindividu[\"profession\"] = \"Développeur\"\nindividu\n\n# Mise à jour de plusieurs clés\nindividu.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\nindividu\n\n# Utilisation de keys()\ncles = individu.keys()\nprint(\"Clés:\", cles)\n\n# Utilisation de values()\nvaleurs = individu.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = individu.items()\nprint(\"Paires clé-valeur:\", paires)\n\n# Utilisation de get()\nnom_personne = individu.get(\"nom\")\nage_personne = individu.get(\"age\")\nprint(nom_personne, age_personne)\n\n# Récupération de la valeur de la clé \"ville\"\nville = individu.get(\"ville\")\nville\n\n# Récupération de la valeur de la clé \"ville\" avec une valeur par défaut\nville = individu.get(\"ville\", \"Non spécifiée\")\nprint(\"Ville:\", ville)\n\n# Parcours des clés\nprint(\"\\nParcours des clés:\")\nfor cle in individu.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in individu.values():\n    print(valeur)\n\n# Parcours des paires clé-valeur\nprint(\"\\nParcours des paires clé-valeur:\")\nfor cle, valeur in individu.items():\n    print(cle, \":\", valeur)\n\n# Parcours des paires clé-valeur avec enumerate\nprint(\"\\nParcours des paires clé-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(individu.items()):\n    print(f\"Index {index}: Clé = {cle}, Valeur = {valeur}\")\n\n# Suppression d'une clé et de sa valeur\ndel individu[\"age\"]\nprint(individu)\n\n# Suppression d'une clé avec retour de sa valeur\nprofession = individu.pop(\"profession\")\nprint(profession)\n\n# Suppression d'une clé avec retour de sa valeur et gestion de l'absence de la clé\nville_supprimee = individu.pop(\"ville\", \"Non spécifiée\")\nprint(ville_supprimee)\n\n# Affichage du dictionnaire après les suppressions\nprint(individu)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClés: dict_keys(['nom', 'age', 'profession'])\nValeurs: dict_values(['Romain', 30, 'Data Scientist'])\nPaires clé-valeur: dict_items([('nom', 'Romain'), ('age', 30), ('profession', 'Data Scientist')])\nRomain 30\nVille: Non spécifiée\n\nParcours des clés:\nnom\nage\nprofession\n\nParcours des valeurs:\nRomain\n30\nData Scientist\n\nParcours des paires clé-valeur:\nnom : Romain\nage : 30\nprofession : Data Scientist\n\nParcours des paires clé-valeur avec enumerate:\nIndex 0: Clé = nom, Valeur = Romain\nIndex 1: Clé = age, Valeur = 30\nIndex 2: Clé = profession, Valeur = Data Scientist\n{'nom': 'Romain', 'profession': 'Data Scientist'}\nData Scientist\nNon spécifiée\n{'nom': 'Romain'}\n```\n:::\n:::\n\n\n<p id=textIntro>Vous êtes maintenant des pros des données séquentielles ! Pensez-vous que cela suffit ? Continuez de vous instruire en <a href=comm_affiche.qmd>cliquant ici</a> pour passer à la suite.</p>\n\n",
    "supporting": [
      "types_donnees_files"
    ],
    "filters": [],
    "includes": {}
  }
}