{
  "hash": "b87a150201e4925226a5b32d9b1fd2a9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Types de donn√©es\n---\n\n### Types de Donn√©es (Structures s√©quentielles)\n\n<p id=textIntro>Chaque type de donn√©es s√©quentielles offre des caract√©ristiques distinctes et des utilisations sp√©cifiques, permettant une grande souplesse dans le traitement des donn√©es. Parmi eux, les listes et les dictionnaires se distinguent par leur flexibilit√© et leurs capacit√©s de stockage dynamique, les rendant particuli√®rement populaires dans de nombreux sc√©narios d'utilisation.</p>\n\n#### Les Chaines de Caract√®res\n\n<p id=textIntro>\nLes **cha√Ænes de caract√®res (str)** sont utilis√©es pour stocker et manipuler du texte. Elles peuvent √™tre d√©finies en encadrant le texte entre des guillemets **simples** ('...'), **doubles** (\"...\"), ou **triples** ('''...''' ou \"\"\"...\"\"\") pour les cha√Ænes multilignes. <br>\nLes cha√Ænes sont des s√©quences de caract√®res **index√©es √† partir de 0** et peuvent contenir des caract√®res sp√©ciaux, comme des guillemets, gr√¢ce aux caract√®res d'√©chappement (\\). Les cha√Ænes de caract√®res offrent une gamme compl√®te de m√©thodes pour le traitement de texte, les rendant extr√™mement polyvalentes et **indispensables** pour une vari√©t√© d'applications, de manipulations de base √† des op√©rations plus complexes. Voici quelques exemples :\n</p>\n\n::: {#4e5155d0 .cell execution_count=1}\n``` {.python .cell-code}\n# Exemples de chaines de caract√®res\n# Chaine de caract√®res simple\nmaChaine = 'Python est un langage de programmation'\n\n# Chaine de caract√®res double\nmaChaine2 = \"Python est un langage de programmation\"\n\n# Chaine avec un caract√®re d'√©chappement\nmaChaine3 = 'Python c\\'est trop bien'\n\nprint(maChaine)\nprint(maChaine2)\nprint(maChaine3)\n\n# On peut acc√©der √† des √©l√©ments\n# Premier caract√®re\npremierCaractere = maChaine[0] # 'P'\n# Dernier caract√®re\ndernierCaractere = maChaine[-1] # 'n'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPython est un langage de programmation\nPython est un langage de programmation\nPython c'est trop bien\n```\n:::\n:::\n\n\n<p id=textIntro> \nLes m√©thodes sont des fonctions associ√©es √† des objets sp√©cifiques, leur permettant d'ex√©cuter des actions sur ces objets ou de manipuler leurs donn√©es internes. Contrairement aux fonctions ind√©pendantes, les m√©thodes sont li√©es √† des objets particuliers.\n<br> Par exemple, les m√©thodes des **cha√Ænes de caract√®res (str)** sont con√ßues pour **op√©rer sur des cha√Ænes de caract√®res sp√©cifiques**. Elles sont appel√©es en utilisant la notation point√©e, comme **objet.methode()**. Les m√©thodes de cha√Ænes de caract√®res incluent des fonctionnalit√©s telles que **upper()**, **lower()**, et **replace()**, permettant de convertir en majuscules, en minuscules ou de remplacer des parties sp√©cifiques de la cha√Æne. Pour appeler une m√©thode, utilisez g√©n√©ralement la syntaxe objet.methode(arguments).\n<br>\nPour utiliser ces m√©thodes vous pouvez les utiliser sur des variables contenant une chaine de caract√®res ou sur des chaines de caract√®res directement.\n</p>\n\n::: {#8b12f826 .cell execution_count=2}\n``` {.python .cell-code}\n# M√©thodes pour les cha√Ænes de caract√®res\n\n# isupper() et islower()\n\nchaineMaj = \"PYTHON\"\nchaineMin = \"python\"\nestMajuscule = chaineMaj.isupper()\nestMinuscule = chaineMin.islower()\nprint(estMajuscule) # R√©sultat : True\nprint(estMinuscule) # R√©sultat : True\n\n# upper() et lower()\nchaine = \"python est g√©nial\"\nminToMaj = chaine.upper()\nprint(minToMaj) # R√©sultat : \"PYTHON EST G√âNIAL\"\n\nmajToMin = \"PYTHON est G√âNIAL\".lower()\nprint(majToMin) # R√©sultat : \"python est g√©nial\"\n\nchaineCapitalize = chaine.capitalize() # La premi√®re lettre est en majuscule\nprint(chaineCapitalize) # R√©sultat : \"Python est g√©nial\"\n\nchaineTitle = chaine.title() # La premi√®re lettre de chaque mot est en majuscule\nprint(chaineTitle) # R√©sultat : \"Python Est G√©nial\"\n\nposition = chaine.find(\"est\") # La m√©thode find() renvoie l'index de la premi√®re occurrence de la cha√Æne recherch√©e\nprint(position) # R√©sultat : 7\n\nchaineReplace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\") # La m√©thode replace() remplace une cha√Æne par une autre\nprint(chaineReplace) # R√©sultat : \"Les bananes sont rouges.\"\n\nchaineSplit = chaine.split(\" \") # La m√©thode split() d√©coupe une cha√Æne en une liste de sous-cha√Ænes\nprint(chaineSplit) # R√©sultat : [\"python\", \"est\", \"genial\"]\n\nelements = [\"apple\", \"orange\", \"banana\"]\ntextJoin = \", \".join(elements) # La m√©thode join() concat√®ne les √©l√©ments d'une liste\nprint(textJoin) # R√©sultat : \"apple, orange, banana\"\n\ntextStrip = \" Bonjour \".strip() # La m√©thode strip() supprime les espaces en d√©but et fin de cha√Æne\nprint(textStrip) # R√©sultat : \"Bonjour\"\n\nchaineStartsWith = chaine.startswith(\"Python\")\nprint(chaineStartsWith) # R√©sultat : True\n\nchaineEndsWith = chaine.endswith(\"g√©nial\")\nprint(chaineEndsWith) # R√©sultat : True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nPYTHON EST G√âNIAL\npython est g√©nial\nPython est g√©nial\nPython Est G√©nial\n7\nLes bananes sont rouges.\n['python', 'est', 'g√©nial']\napple, orange, banana\nBonjour\nFalse\nTrue\n```\n:::\n:::\n\n\n#### Les listes\n<p id=textIntro>\nLes listes repr√©sentent des **structures de donn√©es** permettant de stocker une **s√©quence d'√©l√©ments**. Elles offrent une grande souplesse, car elles peuvent contenir des √©l√©ments de types vari√©s et sont modifiables. En tant que collections ordonn√©es, les √©l√©ments sont organis√©s de mani√®re **s√©quentielle**, s√©par√©s par des virgules et envelopp√©s entre crochets pour les chaines de caract√®res. Pour cr√©er une liste, il suffit d'encadrer une s√©rie d'√©l√©ments avec des crochets, s√©par√©s par des virgules, par exemple : [\"Bonjour\", \"Au revoir\", 75]. L'acc√®s aux √©l√©ments se fait en utilisant leur index, en commen√ßant par 0. √âtant donn√© que les listes sont **mutables**, il est possible de modifier leurs √©l√©ments **apr√®s leur cr√©ation**.\n</p>\n\n::: {#443ac720 .cell execution_count=3}\n``` {.python .cell-code}\n# D√©finition d'une liste\nmaListe = [1, 2, 3, \"a\", \"b\", \"c\"]\nprint(maListe)\n\n# Acc√®s au premier et au dernier √©l√©ment\npremierElement = maListe[0]\ndernierElement = maListe[-1]\nprint(premierElement, \"\\n\", dernierElement)\n\n# Modification du deuxi√®me √©l√©ment\nmaListe[1] = \"deux\" \nprint(maListe)\n\n# Concat√©nation et R√©p√©tition\ncombinee = maListe + [\"autre\", \"liste\"]\nprint(combinee)\n\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 'a', 'b', 'c']\n1 \n c\n[1, 'deux', 3, 'a', 'b', 'c']\n[1, 'deux', 3, 'a', 'b', 'c', 'autre', 'liste']\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n:::\n:::\n\n\n##### Le Slicing\n<p id=textIntro>En plus de permettre l'acc√®s aux √©l√©ments d'une liste un par un, Python propose une syntaxe concise appel√©e **slicing** pour acc√©der aux sous-listes.</p>\n\n::: {#3111a7fd .cell execution_count=4}\n``` {.python .cell-code}\n# D√©finition d'une liste\nmaListe = list(range(5)) # range() est une fonction qui renvoie une liste d'entiers\n\n# Acc√®s √† une sous-liste en utilisant le slicing\nsousListe1 = maListe[1:3]  # R√©cup√®re les √©l√©ments de l'index 1 inclus jusqu'√† l'index 3 non inclus\nsousListe2 = maListe[:3]   # R√©cup√®re les trois premiers √©l√©ments de la liste\nsousListe3 = maListe[2:]   # R√©cup√®re les √©l√©ments √† partir de l'index 2 jusqu'√† la fin de la liste\nsousListe4 = maListe[::2]  # R√©cup√®re les √©l√©ments avec un pas de 2\n\n# Affichage des sous-listes\nprint(\"Sous-liste 1:\", sousListe1)  # R√©sultat : [1, 2]\nprint(\"Sous-liste 2:\", sousListe2)  # R√©sultat : [0, 1, 2]\nprint(\"Sous-liste 3:\", sousListe3)  # R√©sultat : [2, 3, 4]\nprint(\"Sous-liste 4:\", sousListe4)  # R√©sultat : [0, 2, 4]\n\n# Exemples de mutations de listes :\n\n# Cas 1: source de m√™me longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]  # Remplace la sous-liste √† partir de l'index 1 par [4, 5]\nprint(nums1)  # R√©sultat : [1, 4, 5]\n\n# Cas 2: source de longueur diff√©rente\nnums2 = nums1\nnums2[1:] = [6]  # Remplace la sous-liste √† partir de l'index 1 par [6]\nprint(nums2)  # R√©sultat : [1, 6]\n\n# V√©rification si les deux listes pointent vers le m√™me objet en m√©moire\nisSameObject = id(nums1) == id(nums2)  # V√©rifie si les listes pointent vers le m√™me objet\nprint(isSameObject)  # Renvoie True car les listes sont mutables, donc elles sont modifi√©es en place\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSous-liste 1: [1, 2]\nSous-liste 2: [0, 1, 2]\nSous-liste 3: [2, 3, 4]\nSous-liste 4: [0, 2, 4]\n[1, 4, 5]\n[1, 6]\nTrue\n```\n:::\n:::\n\n\n##### Les m√©thodes de listes\n<p id=textIntro>Chaque m√©thode offre une fonctionnalit√© unique pour manipuler des listes, rendant ces structures de donn√©es\nextr√™mement flexibles et puissantes pour une vari√©t√© de t√¢ches en programmation Python.</p>\n\n| **M√©thode** | **Description** | **Exemple d'Utilisation** |\n| --- | --- | --- |\n| **append()** | Ajoute **un √©l√©ment** √† la fin de la liste. | liste.append(5) |\n| **extend()** | √âtend la liste en ajoutant **tous les √©l√©ments d'une autre liste**. | liste.extend([6, 7]) |\n| **insert()** | Ins√®re un √©l√©ment √† une position donn√©e. | liste.insert(1, 'a') |\n| **remove()** | Supprime la premi√®re occurrence d'un √©l√©ment. | liste.remove('a') |\n| **pop()** | Supprime et renvoie un √©l√©ment √† une position donn√©e (par d√©faut, le dernier). | liste.pop() |\n| **clear()** | Supprime tous les √©l√©ments de la liste. | liste.clear() |\n| **index()** | Retourne l'indice du premier √©l√©ment correspondant. | liste.index('a') |\n| **count()** | Compte le nombre d'occurrences d'un √©l√©ment sp√©cifique. | liste.count(5) |\n| **sort()** | Trie les √©l√©ments de la liste (dans un ordre sp√©cifique). | liste.sort() |\n| **reverse()** | Inverse l'ordre des √©l√©ments de la liste. | liste.reverse() |\n\n::: {#45ec986a .cell execution_count=5}\n``` {.python .cell-code}\n# Cr√©ation d'une liste de base\nmaListe = [1, 2, 3]\nprint(maListe)\n\n# Ajout d'un √©l√©ment √† la fin de la liste avec append()\nmaListe.append(\"quatre\")\nprint(\"Apr√®s append(quatre):\", maListe)\n\n# Extension de la liste en ajoutant les √©l√©ments d'une autre liste avec extend()\nmaListe.extend([5, 6])\nprint(\"Apr√®s extend([5, 6]):\", maListe)\n\n# Insertion d'un √©l√©ment √† un index sp√©cifique avec insert()\nmaListe.insert(1, 'elephant')\nprint(\"Apr√®s insert(1, 'elephant'):\", maListe)\n\n# Suppression de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec remove()\nmaListe.remove('elephant')\nprint(\"Apr√®s remove('elephant'):\", maListe)\n\n# Suppression et retour de l'√©l√©ment √† la fin de la liste avec pop()\nelementSupprime = maListe.pop()\nprint(\"Apr√®s pop():\", maListe, \", √âl√©ment supprim√©:\", elementSupprime)\n\n# Suppression de tous les √©l√©ments de la liste avec clear()\nmaListe.clear()\nprint(\"Apr√®s clear():\", maListe)\n\n# Recr√©ation de la liste pour les autres m√©thodes\nmaListe = [3, 1, 4, 2, 2]\n\n# Recherche de l'index de la premi√®re occurrence d'un √©l√©ment sp√©cifi√© avec index()\nindexDe4 = maListe.index(4)\nprint(\"Index de 4:\", indexDe4)\n\n# Comptage du nombre d'occurrences d'un √©l√©ment sp√©cifi√© avec count()\ncompteDe2 = maListe.count(2)\nprint(\"Nombre d'occurrences de 2:\", compteDe2)\n\n# Tri des √©l√©ments de la liste dans l'ordre croissant avec sort()\nmaListe.sort()\nprint(\"Apr√®s sort():\", maListe)\n\n# Inversion de l'ordre des √©l√©ments dans la liste avec reverse()\nmaListe.reverse()\nprint(\"Apr√®s reverse():\", maListe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\nApr√®s append(quatre): [1, 2, 3, 'quatre']\nApr√®s extend([5, 6]): [1, 2, 3, 'quatre', 5, 6]\nApr√®s insert(1, 'elephant'): [1, 'elephant', 2, 3, 'quatre', 5, 6]\nApr√®s remove('elephant'): [1, 2, 3, 'quatre', 5, 6]\nApr√®s pop(): [1, 2, 3, 'quatre', 5] , √âl√©ment supprim√©: 6\nApr√®s clear(): []\nIndex de 4: 2\nNombre d'occurrences de 2: 2\nApr√®s sort(): [1, 2, 2, 3, 4]\nApr√®s reverse(): [4, 3, 2, 2, 1]\n```\n:::\n:::\n\n\n##### Parcours de liste\n<p id=textIntro> Le parcours de liste consiste √† acc√©der s√©quentiellement √† chaque √©l√©ment d'une liste. Cela peut √™tre fait de diff√©rentes\nmani√®res, mais les plus courantes sont les boucles **for** et **while** .</p>\n\n* Boucle for : : La boucle for est la m√©thode la plus couramment utilis√©e pour parcourir une liste. Elle permet de traiter chaque √©l√©ment\nindividuellement.\n\n* List Comprehension : La compr√©hension de liste est une m√©thode concise pour cr√©er des listes. Elle permet de transformer une liste en\nune autre liste, en filtrant les √©l√©ments pour former une liste des r√©sultats d'une expression donn√©e\n\n<p id=textIntro> La syntaxe de base d'une compr√©hension de liste est :\n**[**``nouvelle_expression`` **for ``item`` **in** ``iterable`` **if** ``condition``**]**\n<ul>\n<li><p id=textIntro>**nouvelle_expression** est l'expression qui d√©finit comment **mapper** les √©l√©ments de l' iterable (par exemple, une liste).</p></li>\n<li><p id=textIntro>**item** est la variable qui prend la valeur de chaque √©l√©ment de l' iterable pendant chaque it√©ration.</p></li>\n<li><p id=textIntro> **condition** est une condition optionnelle pour filtrer les √©l√©ments de l' iterable. </p>\n</li>\n</ul>\n<p id=textIntro>Nous allons voir des exemples de parcours de liste en utilisant une boucle for puis en utilisant une **list comprehension** :</p>\n\n::: {#7567d458 .cell execution_count=6}\n``` {.python .cell-code}\n# r√©cup√©rer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nautreListe = []\nautreListe2 = []\n\n# Avec une boucle for\nfor f in fruits:\n    if \"a\" in f:\n        autreListe.append(f)\nprint(autreListe)\n\n# Avec une list comprehension\nautreListe2 = [f for f in fruits if \"a\" in f ]\nprint(autreListe2)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['apple', 'banana', 'mango']\n['apple', 'banana', 'mango']\n```\n:::\n:::\n\n\n<p id=textIntro>Nous pouvons voir que **les list comprehension** sont un moyen d'√©crire un code plus concis mais toujours autant compr√©hensible ! Alors pourquoi se prendre la t√™te avec une boucle for ? üòé\n<br>\nElles peuvent aussi √™tre utilis√©es pour effectuer des calculs sur tous les √©l√©ments d'une liste. Voyons √ßa :</p>\n\n::: {#c66152e2 .cell execution_count=7}\n``` {.python .cell-code}\n# Elevation des nombres d'une liste au carr√©\nnombres = [2, 5, 10, 111]\nnombreCarres = [x**2 for x in nombres]\nprint(nombreCarres) # [4, 25, 100, 12321]\n\n# Filtrer les nombres pairs d'une liste\ncarresPairs = [x for x in nombreCarres if x%2==0]\nprint(carresPairs)\n\n# Appliquer une m√©thode √† tous les √©l√©ments\nfruits_majuscule = [fruit.upper() for fruit in fruits]\nprint(fruits_majuscule)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4, 25, 100, 12321]\n[4, 100]\n['APPLE', 'BANANA', 'CHERRY', 'KIWI', 'MANGO']\n```\n:::\n:::\n\n\n#### Les tuples\n\n<p id=textIntro>Les tuples sont des listes **non mutables**. Cela signifie que les √©l√©ments d'un tuple ne peuvent pas √™tre modifi√©s apr√®s cr√©ation. Les √©l√©ments sont s√©par√©s par d√© virgules et sont entour√©s de parenth√®ses.</p>\n\n| **Avantage**                      | **Description**                                               |\n|------------------------------|-----------------------------------------------------------|\n| **S√©curit√© des Donn√©es**         | Parfait pour prot√©ger les donn√©es contre les modifications. |\n| **Performance**                  | Plus rapides √† parcourir que les listes.                 |\n| **Utilisation en tant que Cl√©s de Dictionnaire** | Peuvent √™tre utilis√©s comme cl√©s dans les dictionnaires, contrairement aux listes. |\n| **Retour de Plusieurs Valeurs de Fonction** | Utilis√©s pour retourner plusieurs valeurs depuis une fonction. |\n| **Stockage de Donn√©es Constantes** | Id√©aux pour stocker des donn√©es qui ne doivent pas √™tre modifi√©es. |\n\n::: {#d8e5f2c6 .cell execution_count=8}\n``` {.python .cell-code}\n# D√©finition d'un tuple\nmonTuple = (10, \"b\", 3.14)\nprint(monTuple)\n\nunAutreTuple = 20, \"c\", 4.28\nprint(unAutreTuple)\n\nelementIndex1 = monTuple[1]\nprint(elementIndex1)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = 50,\nprint(tupleSingleton)\n\n# Tuple √† Un √âl√©ment\ntupleSingleton = (50,)\n\n# Imbrication\ntupleImbrique = (10, (20, 30), (40, 50))\n\n# M√©thodes Utiles\nlongueur = len(monTuple)  # Retourne la longueur de monTuple, ici 3\nprint(longueur)\n\ncompteur = monTuple.count(\"b\")  # Compte le nombre de fois que \"b\" appara√Æt dans monTuple, ici 1\nprint(compteur)\n\nindice = monTuple.index(\"b\")  # Trouve l'indice de \"b\" dans monTuple, ici 1\nprint(indice)\n\n# L'affectation n'est pas possible\n# monTuple[1] = \"c\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(10, 'b', 3.14)\n(20, 'c', 4.28)\nb\n(50,)\n3\n1\n1\n```\n:::\n:::\n\n\n#### Les ensembles\n<p id=textIntro>Les ensembles sont :</p>\n\n* Des collections non ordonn√©es de **valeurs uniques**\n\n* **Mutables**, mais chaque √©l√©ment doit √™tre **unique**.\n\n* **Non-Ordonn√©s** : Les ensembles ne **maintiennent pas** l'ordre des √©l√©ments. On ne peut donc pas acc√©der aux √©l√©ments par un index.\n\n* Les √©l√©ments sont s√©par√©s par des virgules, et encadr√©s par des accolades\n\n##### Op√©rations sur les ensembles\n\n| **Op√©ration**         | **Syntaxe**    | Description                                                                              |\n|-----------------------|---------------|------------------------------------------------------------------------------------------|\n| **Union**             | **a \\| b**    | Retourne un nouvel ensemble contenant tous les √©l√©ments uniques des ensembles a et b.   |\n| **Intersection**      | **a & b**     | Retourne un nouvel ensemble contenant uniquement les √©l√©ments communs aux ensembles a et b. |\n| **Diff√©rence**        | **a - b**     | Retourne un nouvel ensemble contenant les √©l√©ments de a qui ne sont pas dans b.          |\n| **Diff√©rence Sym√©trique** | **a ^ b** | Retourne un nouvel ensemble contenant tous les √©l√©ments qui sont dans a ou b, mais pas dans les deux. |\n| **Ajout**             | **a.add(x)**  | Ajoute l'√©l√©ment x √† l'ensemble a.                                                     |\n| **Suppression**       | **a.remove(x)**| Supprime l'√©l√©ment x de l'ensemble a ; **l√®ve une erreur si x n'est pas pr√©sent**.           |\n| **Suppression (sans erreur)** | **a.discard(x)** | Supprime l'√©l√©ment x de l'ensemble a si x est pr√©sent ; **ne fait rien sinon**.           |\n\n#### Les dictionnaires\n\n<p id=textIntro>Les dictionnaires sont un peu comme un format de JSON :</p>\n\n* Ils sont bas√©s sur des paires **cl√©s-valeurs**\n* On acc√®de aux valeurs via les **cl√©s**\n* Ils sont **mutables**, on peut y **ajouter** des √©l√©ments, en **supprimer** ou en **modifier**\n*   \n* Utilisation :\n- **Stockage d'Informations Structur√©es** : Parfait pour stocker des informations complexes comme des donn√©es utilisateur.\n- **Recherche Rapide** : Utilisez des dictionnaires pour des recherches rapides bas√©es sur des cl√©s uniques\n\n<p id=textIntro>Il existe des m√©thodes li√©es aux variables de type dictionnaire pour les manier :</p>\n\n| M√©thode                | Description                                                                                   |\n|------------------------|-----------------------------------------------------------------------------------------------|\n| **`dict.keys()`**      | Retourne une vue sur les cl√©s du dictionnaire.                                               |\n| **`dict.values()`**    | Retourne une vue sur les valeurs du dictionnaire.                                            |\n| **`dict.items()`**     | Retourne une vue sur les paires (cl√©, valeur) du dictionnaire.                               |\n| **`dict.get(key)`**    | Retourne la valeur associ√©e √† la cl√© sp√©cifi√©e.                                               |\n|                        | Si la cl√© n'existe pas, retourne `None` ou une valeur par d√©faut sp√©cifi√©e en argument.       |\n| **`dict.pop(key)`**    | Retourne la valeur associ√©e √† la cl√© sp√©cifi√©e et supprime cette paire du dictionnaire.\n|                        | Si la cl√© n'existe pas, retourne une valeur par d√©faut sp√©cifi√©e en argument ou l√®ve une erreur.                                                                             |\n| **`dict.popitem()`**  | Retourne et supprime une paire (cl√©, valeur) arbitraire du dictionnaire.                     |\n| **`dict.update(other_dict)`** | Met √† jour le dictionnaire avec les paires cl√©-valeur du dictionnaire sp√©cifi√© en argument. |\n| **`dict.clear()`**     | Supprime toutes les paires cl√©-valeur du dictionnaire, le laissant vide.                      |\n\n::: {#45c18319 .cell execution_count=9}\n``` {.python .cell-code}\n# Cr√©ation d'un dictionnaire\nindividu = {\"nom\": \"Alice\", \"age\": 30}\nautre_dictionnaire = dict(nom=\"Bob\", age=25)\nindividu\n\n# Ajout et mise √† jour\nindividu[\"profession\"] = \"D√©veloppeur\"\nindividu\n\n# Mise √† jour de plusieurs cl√©s\nindividu.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\nindividu\n\n# Utilisation de keys()\ncles = individu.keys()\nprint(\"Cl√©s:\", cles)\n\n# Utilisation de values()\nvaleurs = individu.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = individu.items()\nprint(\"Paires cl√©-valeur:\", paires)\n\n# Utilisation de get()\nnom_personne = individu.get(\"nom\")\nage_personne = individu.get(\"age\")\nprint(nom_personne, age_personne)\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\"\nville = individu.get(\"ville\")\nville\n\n# R√©cup√©ration de la valeur de la cl√© \"ville\" avec une valeur par d√©faut\nville = individu.get(\"ville\", \"Non sp√©cifi√©e\")\nprint(\"Ville:\", ville)\n\n# Parcours des cl√©s\nprint(\"\\nParcours des cl√©s:\")\nfor cle in individu.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in individu.values():\n    print(valeur)\n\n# Parcours des paires cl√©-valeur\nprint(\"\\nParcours des paires cl√©-valeur:\")\nfor cle, valeur in individu.items():\n    print(cle, \":\", valeur)\n\n# Parcours des paires cl√©-valeur avec enumerate\nprint(\"\\nParcours des paires cl√©-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(individu.items()):\n    print(f\"Index {index}: Cl√© = {cle}, Valeur = {valeur}\")\n\n# Suppression d'une cl√© et de sa valeur\ndel individu[\"age\"]\nprint(individu)\n\n# Suppression d'une cl√© avec retour de sa valeur\nprofession = individu.pop(\"profession\")\nprint(profession)\n\n# Suppression d'une cl√© avec retour de sa valeur et gestion de l'absence de la cl√©\nville_supprimee = individu.pop(\"ville\", \"Non sp√©cifi√©e\")\nprint(ville_supprimee)\n\n# Affichage du dictionnaire apr√®s les suppressions\nprint(individu)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCl√©s: dict_keys(['nom', 'age', 'profession'])\nValeurs: dict_values(['Romain', 30, 'Data Scientist'])\nPaires cl√©-valeur: dict_items([('nom', 'Romain'), ('age', 30), ('profession', 'Data Scientist')])\nRomain 30\nVille: Non sp√©cifi√©e\n\nParcours des cl√©s:\nnom\nage\nprofession\n\nParcours des valeurs:\nRomain\n30\nData Scientist\n\nParcours des paires cl√©-valeur:\nnom : Romain\nage : 30\nprofession : Data Scientist\n\nParcours des paires cl√©-valeur avec enumerate:\nIndex 0: Cl√© = nom, Valeur = Romain\nIndex 1: Cl√© = age, Valeur = 30\nIndex 2: Cl√© = profession, Valeur = Data Scientist\n{'nom': 'Romain', 'profession': 'Data Scientist'}\nData Scientist\nNon sp√©cifi√©e\n{'nom': 'Romain'}\n```\n:::\n:::\n\n\n<p id=textIntro>Vous √™tes maintenant des pros des donn√©es s√©quentielles ! Pensez-vous que cela suffit ? Continuez de vous instruire en <a href=comm_affiche.qmd>cliquant ici</a> pour passer √† la suite.</p>\n\n",
    "supporting": [
      "types_donnees_files"
    ],
    "filters": [],
    "includes": {}
  }
}